Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LOOP
    DOTOP
    ANDOP
    OROPE
    SLCOM
    BLCOM
    COLON

Grammar

Rule 0     S' -> foo
Rule 1     foo -> program
Rule 2     program -> declarationList
Rule 3     declarationList -> declaration
Rule 4     declarationList -> declaration declarationList
Rule 5     declaration -> varDeclaration
Rule 6     declaration -> constDeclaration
Rule 7     declaration -> staticDeclaration
Rule 8     declaration -> funcDeclaration
Rule 9     varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL
Rule 10    varDeclaration -> LET IDVAR EQUAL INTVR SEMCL
Rule 11    varDeclaration -> LET IDVAR EQUAL STRNG SEMCL
Rule 12    varDeclaration -> LET IDVAR EQUAL expression SEMCL
Rule 13    constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL
Rule 14    staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL
Rule 15    funcDeclaration -> FN function
Rule 16    function -> FN parameters block
Rule 17    parameters -> OPENP CLOSP
Rule 18    parameters -> OPENP paramList CLOSP
Rule 19    paramList -> parameter
Rule 20    paramList -> parameter COMMA paramList
Rule 21    parameter -> IDVAR
Rule 22    block -> LBCKT RBCKT
Rule 23    block -> LBCKT statement-list RBCKT
Rule 24    statement-list -> stmt
Rule 25    statement-list -> stmt statement-list
Rule 26    stmt -> expression
Rule 27    stmt -> declaration
Rule 28    stmt -> selectionStmt
Rule 29    stmt -> iterationStmt
Rule 30    stmt -> inputStmt
Rule 31    stmt -> outputStmt
Rule 32    expression -> basicExp
Rule 33    expression -> assignmentExp SEMCL
Rule 34    expression -> comparisonExp
Rule 35    expression -> boolExp
Rule 36    basicExp -> IDVAR
Rule 37    basicExp -> INTVR
Rule 38    basicExp -> STRNG
Rule 39    identifier -> IDVAR
Rule 40    identifier -> INTVR
Rule 41    assignmentExp -> identifier sumOp basicExp
Rule 42    assignmentExp -> identifier sumOp assignmentExp
Rule 43    comparisonExp -> basicExp relop basicExp
Rule 44    comparisonExp -> basicExp relop comparisonExp
Rule 45    relop -> LESST
Rule 46    relop -> LSSEQ
Rule 47    relop -> GREAT
Rule 48    relop -> GRTEQ
Rule 49    relop -> EQUAL
Rule 50    relop -> UNEQL
Rule 51    relop -> EQLTO
Rule 52    sumOp -> ADDOP
Rule 53    sumOp -> SUBOP
Rule 54    sumOp -> DEROP
Rule 55    sumOp -> QUOOP
Rule 56    sumOp -> EQUAL
Rule 57    sumOp -> REMOP
Rule 58    selectionStmt -> IF expression EQUAL block
Rule 59    selectionStmt -> IF expression EQUAL block ELSE
Rule 60    iterationStmt -> FOR expression IN expression
Rule 61    iterationStmt -> WHILE expression EQUAL expression
Rule 62    iterationStmt -> WHILE expression LESST expression
Rule 63    iterationStmt -> WHILE expression GREAT expression
Rule 64    inputStmt -> STDIN OPENP stmt CLOSP
Rule 65    outputStmt -> PRINTLN OPENP stmt CLOSP
Rule 66    boolExp -> TRUE
Rule 67    boolExp -> FALSE

Terminals, with rules where they appear

ADDOP                : 52
ANDOP                : 
BLCOM                : 
CLOSP                : 17 18 64 65
COLON                : 
COMMA                : 20
CONST                : 13
DEROP                : 54
DOTOP                : 
ELSE                 : 59
EQLTO                : 51
EQUAL                : 9 10 11 12 13 14 49 56 58 59 61
FALSE                : 67
FN                   : 15 16
FOR                  : 60
GREAT                : 47 63
GRTEQ                : 48
IDVAR                : 9 9 10 11 12 13 13 14 14 21 36 39
IF                   : 58 59
IN                   : 60
INTVR                : 10 37 40
LBCKT                : 22 23
LESST                : 45 62
LET                  : 9 10 11 12
LOOP                 : 
LSSEQ                : 46
OPENP                : 17 18 64 65
OROPE                : 
PRINTLN              : 65
QUOOP                : 55
RBCKT                : 22 23
REMOP                : 57
SEMCL                : 9 10 11 12 13 14 33
SLCOM                : 
STATIC               : 14
STDIN                : 64
STRNG                : 11 38
SUBOP                : 53
TRUE                 : 66
UNEQL                : 50
WHILE                : 61 62 63
error                : 

Nonterminals, with rules where they appear

assignmentExp        : 33 42
basicExp             : 32 41 43 43 44
block                : 16 58 59
boolExp              : 35
comparisonExp        : 34 44
constDeclaration     : 6
declaration          : 3 4 27
declarationList      : 2 4
expression           : 12 26 58 59 60 60 61 61 62 62 63 63
foo                  : 0
funcDeclaration      : 8
function             : 15
identifier           : 41 42
inputStmt            : 30
iterationStmt        : 29
outputStmt           : 31
paramList            : 18 20
parameter            : 19 20
parameters           : 16
program              : 1
relop                : 43 44
selectionStmt        : 28
statement-list       : 23 25
staticDeclaration    : 7
stmt                 : 24 25 64 65
sumOp                : 41 42
varDeclaration       : 5

Parsing method: LALR

state 0

    (0) S' -> . foo
    (1) foo -> . program
    (2) program -> . declarationList
    (3) declarationList -> . declaration
    (4) declarationList -> . declaration declarationList
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function

    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    foo                            shift and go to state 1
    program                        shift and go to state 2
    declarationList                shift and go to state 3
    declaration                    shift and go to state 4
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8

state 1

    (0) S' -> foo .



state 2

    (1) foo -> program .

    $end            reduce using rule 1 (foo -> program .)


state 3

    (2) program -> declarationList .

    $end            reduce using rule 2 (program -> declarationList .)


state 4

    (3) declarationList -> declaration .
    (4) declarationList -> declaration . declarationList
    (3) declarationList -> . declaration
    (4) declarationList -> . declaration declarationList
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function

    $end            reduce using rule 3 (declarationList -> declaration .)
    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    declaration                    shift and go to state 4
    declarationList                shift and go to state 13
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8

state 5

    (5) declaration -> varDeclaration .

    LET             reduce using rule 5 (declaration -> varDeclaration .)
    CONST           reduce using rule 5 (declaration -> varDeclaration .)
    STATIC          reduce using rule 5 (declaration -> varDeclaration .)
    FN              reduce using rule 5 (declaration -> varDeclaration .)
    $end            reduce using rule 5 (declaration -> varDeclaration .)
    IF              reduce using rule 5 (declaration -> varDeclaration .)
    FOR             reduce using rule 5 (declaration -> varDeclaration .)
    WHILE           reduce using rule 5 (declaration -> varDeclaration .)
    STDIN           reduce using rule 5 (declaration -> varDeclaration .)
    PRINTLN         reduce using rule 5 (declaration -> varDeclaration .)
    IDVAR           reduce using rule 5 (declaration -> varDeclaration .)
    INTVR           reduce using rule 5 (declaration -> varDeclaration .)
    STRNG           reduce using rule 5 (declaration -> varDeclaration .)
    TRUE            reduce using rule 5 (declaration -> varDeclaration .)
    FALSE           reduce using rule 5 (declaration -> varDeclaration .)
    RBCKT           reduce using rule 5 (declaration -> varDeclaration .)
    CLOSP           reduce using rule 5 (declaration -> varDeclaration .)


state 6

    (6) declaration -> constDeclaration .

    LET             reduce using rule 6 (declaration -> constDeclaration .)
    CONST           reduce using rule 6 (declaration -> constDeclaration .)
    STATIC          reduce using rule 6 (declaration -> constDeclaration .)
    FN              reduce using rule 6 (declaration -> constDeclaration .)
    $end            reduce using rule 6 (declaration -> constDeclaration .)
    IF              reduce using rule 6 (declaration -> constDeclaration .)
    FOR             reduce using rule 6 (declaration -> constDeclaration .)
    WHILE           reduce using rule 6 (declaration -> constDeclaration .)
    STDIN           reduce using rule 6 (declaration -> constDeclaration .)
    PRINTLN         reduce using rule 6 (declaration -> constDeclaration .)
    IDVAR           reduce using rule 6 (declaration -> constDeclaration .)
    INTVR           reduce using rule 6 (declaration -> constDeclaration .)
    STRNG           reduce using rule 6 (declaration -> constDeclaration .)
    TRUE            reduce using rule 6 (declaration -> constDeclaration .)
    FALSE           reduce using rule 6 (declaration -> constDeclaration .)
    RBCKT           reduce using rule 6 (declaration -> constDeclaration .)
    CLOSP           reduce using rule 6 (declaration -> constDeclaration .)


state 7

    (7) declaration -> staticDeclaration .

    LET             reduce using rule 7 (declaration -> staticDeclaration .)
    CONST           reduce using rule 7 (declaration -> staticDeclaration .)
    STATIC          reduce using rule 7 (declaration -> staticDeclaration .)
    FN              reduce using rule 7 (declaration -> staticDeclaration .)
    $end            reduce using rule 7 (declaration -> staticDeclaration .)
    IF              reduce using rule 7 (declaration -> staticDeclaration .)
    FOR             reduce using rule 7 (declaration -> staticDeclaration .)
    WHILE           reduce using rule 7 (declaration -> staticDeclaration .)
    STDIN           reduce using rule 7 (declaration -> staticDeclaration .)
    PRINTLN         reduce using rule 7 (declaration -> staticDeclaration .)
    IDVAR           reduce using rule 7 (declaration -> staticDeclaration .)
    INTVR           reduce using rule 7 (declaration -> staticDeclaration .)
    STRNG           reduce using rule 7 (declaration -> staticDeclaration .)
    TRUE            reduce using rule 7 (declaration -> staticDeclaration .)
    FALSE           reduce using rule 7 (declaration -> staticDeclaration .)
    RBCKT           reduce using rule 7 (declaration -> staticDeclaration .)
    CLOSP           reduce using rule 7 (declaration -> staticDeclaration .)


state 8

    (8) declaration -> funcDeclaration .

    LET             reduce using rule 8 (declaration -> funcDeclaration .)
    CONST           reduce using rule 8 (declaration -> funcDeclaration .)
    STATIC          reduce using rule 8 (declaration -> funcDeclaration .)
    FN              reduce using rule 8 (declaration -> funcDeclaration .)
    $end            reduce using rule 8 (declaration -> funcDeclaration .)
    IF              reduce using rule 8 (declaration -> funcDeclaration .)
    FOR             reduce using rule 8 (declaration -> funcDeclaration .)
    WHILE           reduce using rule 8 (declaration -> funcDeclaration .)
    STDIN           reduce using rule 8 (declaration -> funcDeclaration .)
    PRINTLN         reduce using rule 8 (declaration -> funcDeclaration .)
    IDVAR           reduce using rule 8 (declaration -> funcDeclaration .)
    INTVR           reduce using rule 8 (declaration -> funcDeclaration .)
    STRNG           reduce using rule 8 (declaration -> funcDeclaration .)
    TRUE            reduce using rule 8 (declaration -> funcDeclaration .)
    FALSE           reduce using rule 8 (declaration -> funcDeclaration .)
    RBCKT           reduce using rule 8 (declaration -> funcDeclaration .)
    CLOSP           reduce using rule 8 (declaration -> funcDeclaration .)


state 9

    (9) varDeclaration -> LET . IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> LET . IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> LET . IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> LET . IDVAR EQUAL expression SEMCL

    IDVAR           shift and go to state 14


state 10

    (13) constDeclaration -> CONST . IDVAR EQUAL IDVAR SEMCL

    IDVAR           shift and go to state 15


state 11

    (14) staticDeclaration -> STATIC . IDVAR EQUAL IDVAR SEMCL

    IDVAR           shift and go to state 16


state 12

    (15) funcDeclaration -> FN . function
    (16) function -> . FN parameters block

    FN              shift and go to state 17

    function                       shift and go to state 18

state 13

    (4) declarationList -> declaration declarationList .

    $end            reduce using rule 4 (declarationList -> declaration declarationList .)


state 14

    (9) varDeclaration -> LET IDVAR . EQUAL IDVAR SEMCL
    (10) varDeclaration -> LET IDVAR . EQUAL INTVR SEMCL
    (11) varDeclaration -> LET IDVAR . EQUAL STRNG SEMCL
    (12) varDeclaration -> LET IDVAR . EQUAL expression SEMCL

    EQUAL           shift and go to state 19


state 15

    (13) constDeclaration -> CONST IDVAR . EQUAL IDVAR SEMCL

    EQUAL           shift and go to state 20


state 16

    (14) staticDeclaration -> STATIC IDVAR . EQUAL IDVAR SEMCL

    EQUAL           shift and go to state 21


state 17

    (16) function -> FN . parameters block
    (17) parameters -> . OPENP CLOSP
    (18) parameters -> . OPENP paramList CLOSP

    OPENP           shift and go to state 23

    parameters                     shift and go to state 22

state 18

    (15) funcDeclaration -> FN function .

    LET             reduce using rule 15 (funcDeclaration -> FN function .)
    CONST           reduce using rule 15 (funcDeclaration -> FN function .)
    STATIC          reduce using rule 15 (funcDeclaration -> FN function .)
    FN              reduce using rule 15 (funcDeclaration -> FN function .)
    $end            reduce using rule 15 (funcDeclaration -> FN function .)
    IF              reduce using rule 15 (funcDeclaration -> FN function .)
    FOR             reduce using rule 15 (funcDeclaration -> FN function .)
    WHILE           reduce using rule 15 (funcDeclaration -> FN function .)
    STDIN           reduce using rule 15 (funcDeclaration -> FN function .)
    PRINTLN         reduce using rule 15 (funcDeclaration -> FN function .)
    IDVAR           reduce using rule 15 (funcDeclaration -> FN function .)
    INTVR           reduce using rule 15 (funcDeclaration -> FN function .)
    STRNG           reduce using rule 15 (funcDeclaration -> FN function .)
    TRUE            reduce using rule 15 (funcDeclaration -> FN function .)
    FALSE           reduce using rule 15 (funcDeclaration -> FN function .)
    RBCKT           reduce using rule 15 (funcDeclaration -> FN function .)
    CLOSP           reduce using rule 15 (funcDeclaration -> FN function .)


state 19

    (9) varDeclaration -> LET IDVAR EQUAL . IDVAR SEMCL
    (10) varDeclaration -> LET IDVAR EQUAL . INTVR SEMCL
    (11) varDeclaration -> LET IDVAR EQUAL . STRNG SEMCL
    (12) varDeclaration -> LET IDVAR EQUAL . expression SEMCL
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 24
    INTVR           shift and go to state 25
    STRNG           shift and go to state 26
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 27
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 20

    (13) constDeclaration -> CONST IDVAR EQUAL . IDVAR SEMCL

    IDVAR           shift and go to state 35


state 21

    (14) staticDeclaration -> STATIC IDVAR EQUAL . IDVAR SEMCL

    IDVAR           shift and go to state 36


state 22

    (16) function -> FN parameters . block
    (22) block -> . LBCKT RBCKT
    (23) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 38

    block                          shift and go to state 37

state 23

    (17) parameters -> OPENP . CLOSP
    (18) parameters -> OPENP . paramList CLOSP
    (19) paramList -> . parameter
    (20) paramList -> . parameter COMMA paramList
    (21) parameter -> . IDVAR

    CLOSP           shift and go to state 39
    IDVAR           shift and go to state 42

    paramList                      shift and go to state 40
    parameter                      shift and go to state 41

state 24

    (9) varDeclaration -> LET IDVAR EQUAL IDVAR . SEMCL
    (36) basicExp -> IDVAR .
    (39) identifier -> IDVAR .

  ! shift/reduce conflict for SEMCL resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 36 (basicExp -> IDVAR .)
    SEMCL           shift and go to state 43
    LESST           reduce using rule 36 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 36 (basicExp -> IDVAR .)
    GREAT           reduce using rule 36 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 36 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 36 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 36 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 36 (basicExp -> IDVAR .)
    ADDOP           reduce using rule 39 (identifier -> IDVAR .)
    SUBOP           reduce using rule 39 (identifier -> IDVAR .)
    DEROP           reduce using rule 39 (identifier -> IDVAR .)
    QUOOP           reduce using rule 39 (identifier -> IDVAR .)
    REMOP           reduce using rule 39 (identifier -> IDVAR .)

  ! SEMCL           [ reduce using rule 36 (basicExp -> IDVAR .) ]
  ! EQUAL           [ reduce using rule 39 (identifier -> IDVAR .) ]


state 25

    (10) varDeclaration -> LET IDVAR EQUAL INTVR . SEMCL
    (37) basicExp -> INTVR .
    (40) identifier -> INTVR .

  ! shift/reduce conflict for SEMCL resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 37 (basicExp -> INTVR .)
    SEMCL           shift and go to state 44
    LESST           reduce using rule 37 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 37 (basicExp -> INTVR .)
    GREAT           reduce using rule 37 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 37 (basicExp -> INTVR .)
    EQUAL           reduce using rule 37 (basicExp -> INTVR .)
    UNEQL           reduce using rule 37 (basicExp -> INTVR .)
    EQLTO           reduce using rule 37 (basicExp -> INTVR .)
    ADDOP           reduce using rule 40 (identifier -> INTVR .)
    SUBOP           reduce using rule 40 (identifier -> INTVR .)
    DEROP           reduce using rule 40 (identifier -> INTVR .)
    QUOOP           reduce using rule 40 (identifier -> INTVR .)
    REMOP           reduce using rule 40 (identifier -> INTVR .)

  ! SEMCL           [ reduce using rule 37 (basicExp -> INTVR .) ]
  ! EQUAL           [ reduce using rule 40 (identifier -> INTVR .) ]


state 26

    (11) varDeclaration -> LET IDVAR EQUAL STRNG . SEMCL
    (38) basicExp -> STRNG .

  ! shift/reduce conflict for SEMCL resolved as shift
    SEMCL           shift and go to state 45
    LESST           reduce using rule 38 (basicExp -> STRNG .)
    LSSEQ           reduce using rule 38 (basicExp -> STRNG .)
    GREAT           reduce using rule 38 (basicExp -> STRNG .)
    GRTEQ           reduce using rule 38 (basicExp -> STRNG .)
    EQUAL           reduce using rule 38 (basicExp -> STRNG .)
    UNEQL           reduce using rule 38 (basicExp -> STRNG .)
    EQLTO           reduce using rule 38 (basicExp -> STRNG .)

  ! SEMCL           [ reduce using rule 38 (basicExp -> STRNG .) ]


state 27

    (12) varDeclaration -> LET IDVAR EQUAL expression . SEMCL

    SEMCL           shift and go to state 46


state 28

    (32) expression -> basicExp .
    (43) comparisonExp -> basicExp . relop basicExp
    (44) comparisonExp -> basicExp . relop comparisonExp
    (45) relop -> . LESST
    (46) relop -> . LSSEQ
    (47) relop -> . GREAT
    (48) relop -> . GRTEQ
    (49) relop -> . EQUAL
    (50) relop -> . UNEQL
    (51) relop -> . EQLTO

  ! shift/reduce conflict for LESST resolved as shift
  ! shift/reduce conflict for GREAT resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
    SEMCL           reduce using rule 32 (expression -> basicExp .)
    IF              reduce using rule 32 (expression -> basicExp .)
    FOR             reduce using rule 32 (expression -> basicExp .)
    WHILE           reduce using rule 32 (expression -> basicExp .)
    STDIN           reduce using rule 32 (expression -> basicExp .)
    PRINTLN         reduce using rule 32 (expression -> basicExp .)
    IDVAR           reduce using rule 32 (expression -> basicExp .)
    INTVR           reduce using rule 32 (expression -> basicExp .)
    STRNG           reduce using rule 32 (expression -> basicExp .)
    TRUE            reduce using rule 32 (expression -> basicExp .)
    FALSE           reduce using rule 32 (expression -> basicExp .)
    LET             reduce using rule 32 (expression -> basicExp .)
    CONST           reduce using rule 32 (expression -> basicExp .)
    STATIC          reduce using rule 32 (expression -> basicExp .)
    FN              reduce using rule 32 (expression -> basicExp .)
    RBCKT           reduce using rule 32 (expression -> basicExp .)
    IN              reduce using rule 32 (expression -> basicExp .)
    CLOSP           reduce using rule 32 (expression -> basicExp .)
    LESST           shift and go to state 48
    LSSEQ           shift and go to state 49
    GREAT           shift and go to state 50
    GRTEQ           shift and go to state 51
    EQUAL           shift and go to state 52
    UNEQL           shift and go to state 53
    EQLTO           shift and go to state 54

  ! EQUAL           [ reduce using rule 32 (expression -> basicExp .) ]
  ! LESST           [ reduce using rule 32 (expression -> basicExp .) ]
  ! GREAT           [ reduce using rule 32 (expression -> basicExp .) ]

    relop                          shift and go to state 47

state 29

    (33) expression -> assignmentExp . SEMCL

    SEMCL           shift and go to state 55


state 30

    (34) expression -> comparisonExp .

    SEMCL           reduce using rule 34 (expression -> comparisonExp .)
    IF              reduce using rule 34 (expression -> comparisonExp .)
    FOR             reduce using rule 34 (expression -> comparisonExp .)
    WHILE           reduce using rule 34 (expression -> comparisonExp .)
    STDIN           reduce using rule 34 (expression -> comparisonExp .)
    PRINTLN         reduce using rule 34 (expression -> comparisonExp .)
    IDVAR           reduce using rule 34 (expression -> comparisonExp .)
    INTVR           reduce using rule 34 (expression -> comparisonExp .)
    STRNG           reduce using rule 34 (expression -> comparisonExp .)
    TRUE            reduce using rule 34 (expression -> comparisonExp .)
    FALSE           reduce using rule 34 (expression -> comparisonExp .)
    LET             reduce using rule 34 (expression -> comparisonExp .)
    CONST           reduce using rule 34 (expression -> comparisonExp .)
    STATIC          reduce using rule 34 (expression -> comparisonExp .)
    FN              reduce using rule 34 (expression -> comparisonExp .)
    RBCKT           reduce using rule 34 (expression -> comparisonExp .)
    EQUAL           reduce using rule 34 (expression -> comparisonExp .)
    IN              reduce using rule 34 (expression -> comparisonExp .)
    LESST           reduce using rule 34 (expression -> comparisonExp .)
    GREAT           reduce using rule 34 (expression -> comparisonExp .)
    CLOSP           reduce using rule 34 (expression -> comparisonExp .)


state 31

    (35) expression -> boolExp .

    SEMCL           reduce using rule 35 (expression -> boolExp .)
    IF              reduce using rule 35 (expression -> boolExp .)
    FOR             reduce using rule 35 (expression -> boolExp .)
    WHILE           reduce using rule 35 (expression -> boolExp .)
    STDIN           reduce using rule 35 (expression -> boolExp .)
    PRINTLN         reduce using rule 35 (expression -> boolExp .)
    IDVAR           reduce using rule 35 (expression -> boolExp .)
    INTVR           reduce using rule 35 (expression -> boolExp .)
    STRNG           reduce using rule 35 (expression -> boolExp .)
    TRUE            reduce using rule 35 (expression -> boolExp .)
    FALSE           reduce using rule 35 (expression -> boolExp .)
    LET             reduce using rule 35 (expression -> boolExp .)
    CONST           reduce using rule 35 (expression -> boolExp .)
    STATIC          reduce using rule 35 (expression -> boolExp .)
    FN              reduce using rule 35 (expression -> boolExp .)
    RBCKT           reduce using rule 35 (expression -> boolExp .)
    EQUAL           reduce using rule 35 (expression -> boolExp .)
    IN              reduce using rule 35 (expression -> boolExp .)
    LESST           reduce using rule 35 (expression -> boolExp .)
    GREAT           reduce using rule 35 (expression -> boolExp .)
    CLOSP           reduce using rule 35 (expression -> boolExp .)


state 32

    (41) assignmentExp -> identifier . sumOp basicExp
    (42) assignmentExp -> identifier . sumOp assignmentExp
    (52) sumOp -> . ADDOP
    (53) sumOp -> . SUBOP
    (54) sumOp -> . DEROP
    (55) sumOp -> . QUOOP
    (56) sumOp -> . EQUAL
    (57) sumOp -> . REMOP

    ADDOP           shift and go to state 57
    SUBOP           shift and go to state 58
    DEROP           shift and go to state 59
    QUOOP           shift and go to state 60
    EQUAL           shift and go to state 61
    REMOP           shift and go to state 62

    sumOp                          shift and go to state 56

state 33

    (66) boolExp -> TRUE .

    SEMCL           reduce using rule 66 (boolExp -> TRUE .)
    IF              reduce using rule 66 (boolExp -> TRUE .)
    FOR             reduce using rule 66 (boolExp -> TRUE .)
    WHILE           reduce using rule 66 (boolExp -> TRUE .)
    STDIN           reduce using rule 66 (boolExp -> TRUE .)
    PRINTLN         reduce using rule 66 (boolExp -> TRUE .)
    IDVAR           reduce using rule 66 (boolExp -> TRUE .)
    INTVR           reduce using rule 66 (boolExp -> TRUE .)
    STRNG           reduce using rule 66 (boolExp -> TRUE .)
    TRUE            reduce using rule 66 (boolExp -> TRUE .)
    FALSE           reduce using rule 66 (boolExp -> TRUE .)
    LET             reduce using rule 66 (boolExp -> TRUE .)
    CONST           reduce using rule 66 (boolExp -> TRUE .)
    STATIC          reduce using rule 66 (boolExp -> TRUE .)
    FN              reduce using rule 66 (boolExp -> TRUE .)
    RBCKT           reduce using rule 66 (boolExp -> TRUE .)
    EQUAL           reduce using rule 66 (boolExp -> TRUE .)
    IN              reduce using rule 66 (boolExp -> TRUE .)
    LESST           reduce using rule 66 (boolExp -> TRUE .)
    GREAT           reduce using rule 66 (boolExp -> TRUE .)
    CLOSP           reduce using rule 66 (boolExp -> TRUE .)


state 34

    (67) boolExp -> FALSE .

    SEMCL           reduce using rule 67 (boolExp -> FALSE .)
    IF              reduce using rule 67 (boolExp -> FALSE .)
    FOR             reduce using rule 67 (boolExp -> FALSE .)
    WHILE           reduce using rule 67 (boolExp -> FALSE .)
    STDIN           reduce using rule 67 (boolExp -> FALSE .)
    PRINTLN         reduce using rule 67 (boolExp -> FALSE .)
    IDVAR           reduce using rule 67 (boolExp -> FALSE .)
    INTVR           reduce using rule 67 (boolExp -> FALSE .)
    STRNG           reduce using rule 67 (boolExp -> FALSE .)
    TRUE            reduce using rule 67 (boolExp -> FALSE .)
    FALSE           reduce using rule 67 (boolExp -> FALSE .)
    LET             reduce using rule 67 (boolExp -> FALSE .)
    CONST           reduce using rule 67 (boolExp -> FALSE .)
    STATIC          reduce using rule 67 (boolExp -> FALSE .)
    FN              reduce using rule 67 (boolExp -> FALSE .)
    RBCKT           reduce using rule 67 (boolExp -> FALSE .)
    EQUAL           reduce using rule 67 (boolExp -> FALSE .)
    IN              reduce using rule 67 (boolExp -> FALSE .)
    LESST           reduce using rule 67 (boolExp -> FALSE .)
    GREAT           reduce using rule 67 (boolExp -> FALSE .)
    CLOSP           reduce using rule 67 (boolExp -> FALSE .)


state 35

    (13) constDeclaration -> CONST IDVAR EQUAL IDVAR . SEMCL

    SEMCL           shift and go to state 63


state 36

    (14) staticDeclaration -> STATIC IDVAR EQUAL IDVAR . SEMCL

    SEMCL           shift and go to state 64


state 37

    (16) function -> FN parameters block .

    LET             reduce using rule 16 (function -> FN parameters block .)
    CONST           reduce using rule 16 (function -> FN parameters block .)
    STATIC          reduce using rule 16 (function -> FN parameters block .)
    FN              reduce using rule 16 (function -> FN parameters block .)
    $end            reduce using rule 16 (function -> FN parameters block .)
    IF              reduce using rule 16 (function -> FN parameters block .)
    FOR             reduce using rule 16 (function -> FN parameters block .)
    WHILE           reduce using rule 16 (function -> FN parameters block .)
    STDIN           reduce using rule 16 (function -> FN parameters block .)
    PRINTLN         reduce using rule 16 (function -> FN parameters block .)
    IDVAR           reduce using rule 16 (function -> FN parameters block .)
    INTVR           reduce using rule 16 (function -> FN parameters block .)
    STRNG           reduce using rule 16 (function -> FN parameters block .)
    TRUE            reduce using rule 16 (function -> FN parameters block .)
    FALSE           reduce using rule 16 (function -> FN parameters block .)
    RBCKT           reduce using rule 16 (function -> FN parameters block .)
    CLOSP           reduce using rule 16 (function -> FN parameters block .)


state 38

    (22) block -> LBCKT . RBCKT
    (23) block -> LBCKT . statement-list RBCKT
    (24) statement-list -> . stmt
    (25) statement-list -> . stmt statement-list
    (26) stmt -> . expression
    (27) stmt -> . declaration
    (28) stmt -> . selectionStmt
    (29) stmt -> . iterationStmt
    (30) stmt -> . inputStmt
    (31) stmt -> . outputStmt
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (58) selectionStmt -> . IF expression EQUAL block
    (59) selectionStmt -> . IF expression EQUAL block ELSE
    (60) iterationStmt -> . FOR expression IN expression
    (61) iterationStmt -> . WHILE expression EQUAL expression
    (62) iterationStmt -> . WHILE expression LESST expression
    (63) iterationStmt -> . WHILE expression GREAT expression
    (64) inputStmt -> . STDIN OPENP stmt CLOSP
    (65) outputStmt -> . PRINTLN OPENP stmt CLOSP
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    RBCKT           shift and go to state 65
    IF              shift and go to state 74
    FOR             shift and go to state 75
    WHILE           shift and go to state 76
    STDIN           shift and go to state 77
    PRINTLN         shift and go to state 78
    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    statement-list                 shift and go to state 66
    stmt                           shift and go to state 67
    expression                     shift and go to state 68
    declaration                    shift and go to state 69
    selectionStmt                  shift and go to state 70
    iterationStmt                  shift and go to state 71
    inputStmt                      shift and go to state 72
    outputStmt                     shift and go to state 73
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8
    identifier                     shift and go to state 32

state 39

    (17) parameters -> OPENP CLOSP .

    LBCKT           reduce using rule 17 (parameters -> OPENP CLOSP .)


state 40

    (18) parameters -> OPENP paramList . CLOSP

    CLOSP           shift and go to state 82


state 41

    (19) paramList -> parameter .
    (20) paramList -> parameter . COMMA paramList

    CLOSP           reduce using rule 19 (paramList -> parameter .)
    COMMA           shift and go to state 83


state 42

    (21) parameter -> IDVAR .

    COMMA           reduce using rule 21 (parameter -> IDVAR .)
    CLOSP           reduce using rule 21 (parameter -> IDVAR .)


state 43

    (9) varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .

    LET             reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    CONST           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    STATIC          reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    FN              reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    $end            reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    IF              reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    FOR             reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    WHILE           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    STDIN           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    PRINTLN         reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    IDVAR           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    INTVR           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    STRNG           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    TRUE            reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    FALSE           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    RBCKT           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)
    CLOSP           reduce using rule 9 (varDeclaration -> LET IDVAR EQUAL IDVAR SEMCL .)


state 44

    (10) varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .

    LET             reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    CONST           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    STATIC          reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    FN              reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    $end            reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    IF              reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    FOR             reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    WHILE           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    STDIN           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    PRINTLN         reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    IDVAR           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    INTVR           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    STRNG           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    TRUE            reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    FALSE           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    RBCKT           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)
    CLOSP           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL INTVR SEMCL .)


state 45

    (11) varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .

    LET             reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    CONST           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    STATIC          reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    FN              reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    $end            reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    IF              reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    FOR             reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    WHILE           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    STDIN           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    PRINTLN         reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    IDVAR           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    INTVR           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    STRNG           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    TRUE            reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    FALSE           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    RBCKT           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)
    CLOSP           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL STRNG SEMCL .)


state 46

    (12) varDeclaration -> LET IDVAR EQUAL expression SEMCL .

    LET             reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    CONST           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STATIC          reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FN              reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    $end            reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    IF              reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FOR             reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    WHILE           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STDIN           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    PRINTLN         reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    IDVAR           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    INTVR           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STRNG           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    TRUE            reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FALSE           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    RBCKT           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    CLOSP           reduce using rule 12 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)


state 47

    (43) comparisonExp -> basicExp relop . basicExp
    (44) comparisonExp -> basicExp relop . comparisonExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp

    IDVAR           shift and go to state 86
    INTVR           shift and go to state 87
    STRNG           shift and go to state 81

    basicExp                       shift and go to state 84
    comparisonExp                  shift and go to state 85

state 48

    (45) relop -> LESST .

    IDVAR           reduce using rule 45 (relop -> LESST .)
    INTVR           reduce using rule 45 (relop -> LESST .)
    STRNG           reduce using rule 45 (relop -> LESST .)


state 49

    (46) relop -> LSSEQ .

    IDVAR           reduce using rule 46 (relop -> LSSEQ .)
    INTVR           reduce using rule 46 (relop -> LSSEQ .)
    STRNG           reduce using rule 46 (relop -> LSSEQ .)


state 50

    (47) relop -> GREAT .

    IDVAR           reduce using rule 47 (relop -> GREAT .)
    INTVR           reduce using rule 47 (relop -> GREAT .)
    STRNG           reduce using rule 47 (relop -> GREAT .)


state 51

    (48) relop -> GRTEQ .

    IDVAR           reduce using rule 48 (relop -> GRTEQ .)
    INTVR           reduce using rule 48 (relop -> GRTEQ .)
    STRNG           reduce using rule 48 (relop -> GRTEQ .)


state 52

    (49) relop -> EQUAL .

    IDVAR           reduce using rule 49 (relop -> EQUAL .)
    INTVR           reduce using rule 49 (relop -> EQUAL .)
    STRNG           reduce using rule 49 (relop -> EQUAL .)


state 53

    (50) relop -> UNEQL .

    IDVAR           reduce using rule 50 (relop -> UNEQL .)
    INTVR           reduce using rule 50 (relop -> UNEQL .)
    STRNG           reduce using rule 50 (relop -> UNEQL .)


state 54

    (51) relop -> EQLTO .

    IDVAR           reduce using rule 51 (relop -> EQLTO .)
    INTVR           reduce using rule 51 (relop -> EQLTO .)
    STRNG           reduce using rule 51 (relop -> EQLTO .)


state 55

    (33) expression -> assignmentExp SEMCL .

    SEMCL           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    IF              reduce using rule 33 (expression -> assignmentExp SEMCL .)
    FOR             reduce using rule 33 (expression -> assignmentExp SEMCL .)
    WHILE           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    STDIN           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    PRINTLN         reduce using rule 33 (expression -> assignmentExp SEMCL .)
    IDVAR           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    INTVR           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    STRNG           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    TRUE            reduce using rule 33 (expression -> assignmentExp SEMCL .)
    FALSE           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    LET             reduce using rule 33 (expression -> assignmentExp SEMCL .)
    CONST           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    STATIC          reduce using rule 33 (expression -> assignmentExp SEMCL .)
    FN              reduce using rule 33 (expression -> assignmentExp SEMCL .)
    RBCKT           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    EQUAL           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    IN              reduce using rule 33 (expression -> assignmentExp SEMCL .)
    LESST           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    GREAT           reduce using rule 33 (expression -> assignmentExp SEMCL .)
    CLOSP           reduce using rule 33 (expression -> assignmentExp SEMCL .)


state 56

    (41) assignmentExp -> identifier sumOp . basicExp
    (42) assignmentExp -> identifier sumOp . assignmentExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81

    identifier                     shift and go to state 32
    basicExp                       shift and go to state 88
    assignmentExp                  shift and go to state 89

state 57

    (52) sumOp -> ADDOP .

    IDVAR           reduce using rule 52 (sumOp -> ADDOP .)
    INTVR           reduce using rule 52 (sumOp -> ADDOP .)
    STRNG           reduce using rule 52 (sumOp -> ADDOP .)


state 58

    (53) sumOp -> SUBOP .

    IDVAR           reduce using rule 53 (sumOp -> SUBOP .)
    INTVR           reduce using rule 53 (sumOp -> SUBOP .)
    STRNG           reduce using rule 53 (sumOp -> SUBOP .)


state 59

    (54) sumOp -> DEROP .

    IDVAR           reduce using rule 54 (sumOp -> DEROP .)
    INTVR           reduce using rule 54 (sumOp -> DEROP .)
    STRNG           reduce using rule 54 (sumOp -> DEROP .)


state 60

    (55) sumOp -> QUOOP .

    IDVAR           reduce using rule 55 (sumOp -> QUOOP .)
    INTVR           reduce using rule 55 (sumOp -> QUOOP .)
    STRNG           reduce using rule 55 (sumOp -> QUOOP .)


state 61

    (56) sumOp -> EQUAL .

    IDVAR           reduce using rule 56 (sumOp -> EQUAL .)
    INTVR           reduce using rule 56 (sumOp -> EQUAL .)
    STRNG           reduce using rule 56 (sumOp -> EQUAL .)


state 62

    (57) sumOp -> REMOP .

    IDVAR           reduce using rule 57 (sumOp -> REMOP .)
    INTVR           reduce using rule 57 (sumOp -> REMOP .)
    STRNG           reduce using rule 57 (sumOp -> REMOP .)


state 63

    (13) constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .

    LET             reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    CONST           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    STATIC          reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    FN              reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    $end            reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    IF              reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    FOR             reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    WHILE           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    STDIN           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    PRINTLN         reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    IDVAR           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    INTVR           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    STRNG           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    TRUE            reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    FALSE           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    RBCKT           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)
    CLOSP           reduce using rule 13 (constDeclaration -> CONST IDVAR EQUAL IDVAR SEMCL .)


state 64

    (14) staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .

    LET             reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    CONST           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    STATIC          reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    FN              reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    $end            reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    IF              reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    FOR             reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    WHILE           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    STDIN           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    PRINTLN         reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    IDVAR           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    INTVR           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    STRNG           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    TRUE            reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    FALSE           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    RBCKT           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)
    CLOSP           reduce using rule 14 (staticDeclaration -> STATIC IDVAR EQUAL IDVAR SEMCL .)


state 65

    (22) block -> LBCKT RBCKT .

    LET             reduce using rule 22 (block -> LBCKT RBCKT .)
    CONST           reduce using rule 22 (block -> LBCKT RBCKT .)
    STATIC          reduce using rule 22 (block -> LBCKT RBCKT .)
    FN              reduce using rule 22 (block -> LBCKT RBCKT .)
    $end            reduce using rule 22 (block -> LBCKT RBCKT .)
    IF              reduce using rule 22 (block -> LBCKT RBCKT .)
    FOR             reduce using rule 22 (block -> LBCKT RBCKT .)
    WHILE           reduce using rule 22 (block -> LBCKT RBCKT .)
    STDIN           reduce using rule 22 (block -> LBCKT RBCKT .)
    PRINTLN         reduce using rule 22 (block -> LBCKT RBCKT .)
    IDVAR           reduce using rule 22 (block -> LBCKT RBCKT .)
    INTVR           reduce using rule 22 (block -> LBCKT RBCKT .)
    STRNG           reduce using rule 22 (block -> LBCKT RBCKT .)
    TRUE            reduce using rule 22 (block -> LBCKT RBCKT .)
    FALSE           reduce using rule 22 (block -> LBCKT RBCKT .)
    RBCKT           reduce using rule 22 (block -> LBCKT RBCKT .)
    CLOSP           reduce using rule 22 (block -> LBCKT RBCKT .)
    ELSE            reduce using rule 22 (block -> LBCKT RBCKT .)


state 66

    (23) block -> LBCKT statement-list . RBCKT

    RBCKT           shift and go to state 90


state 67

    (24) statement-list -> stmt .
    (25) statement-list -> stmt . statement-list
    (24) statement-list -> . stmt
    (25) statement-list -> . stmt statement-list
    (26) stmt -> . expression
    (27) stmt -> . declaration
    (28) stmt -> . selectionStmt
    (29) stmt -> . iterationStmt
    (30) stmt -> . inputStmt
    (31) stmt -> . outputStmt
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (58) selectionStmt -> . IF expression EQUAL block
    (59) selectionStmt -> . IF expression EQUAL block ELSE
    (60) iterationStmt -> . FOR expression IN expression
    (61) iterationStmt -> . WHILE expression EQUAL expression
    (62) iterationStmt -> . WHILE expression LESST expression
    (63) iterationStmt -> . WHILE expression GREAT expression
    (64) inputStmt -> . STDIN OPENP stmt CLOSP
    (65) outputStmt -> . PRINTLN OPENP stmt CLOSP
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    RBCKT           reduce using rule 24 (statement-list -> stmt .)
    IF              shift and go to state 74
    FOR             shift and go to state 75
    WHILE           shift and go to state 76
    STDIN           shift and go to state 77
    PRINTLN         shift and go to state 78
    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    stmt                           shift and go to state 67
    statement-list                 shift and go to state 91
    expression                     shift and go to state 68
    declaration                    shift and go to state 69
    selectionStmt                  shift and go to state 70
    iterationStmt                  shift and go to state 71
    inputStmt                      shift and go to state 72
    outputStmt                     shift and go to state 73
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8
    identifier                     shift and go to state 32

state 68

    (26) stmt -> expression .

    IF              reduce using rule 26 (stmt -> expression .)
    FOR             reduce using rule 26 (stmt -> expression .)
    WHILE           reduce using rule 26 (stmt -> expression .)
    STDIN           reduce using rule 26 (stmt -> expression .)
    PRINTLN         reduce using rule 26 (stmt -> expression .)
    IDVAR           reduce using rule 26 (stmt -> expression .)
    INTVR           reduce using rule 26 (stmt -> expression .)
    STRNG           reduce using rule 26 (stmt -> expression .)
    TRUE            reduce using rule 26 (stmt -> expression .)
    FALSE           reduce using rule 26 (stmt -> expression .)
    LET             reduce using rule 26 (stmt -> expression .)
    CONST           reduce using rule 26 (stmt -> expression .)
    STATIC          reduce using rule 26 (stmt -> expression .)
    FN              reduce using rule 26 (stmt -> expression .)
    RBCKT           reduce using rule 26 (stmt -> expression .)
    CLOSP           reduce using rule 26 (stmt -> expression .)


state 69

    (27) stmt -> declaration .

    IF              reduce using rule 27 (stmt -> declaration .)
    FOR             reduce using rule 27 (stmt -> declaration .)
    WHILE           reduce using rule 27 (stmt -> declaration .)
    STDIN           reduce using rule 27 (stmt -> declaration .)
    PRINTLN         reduce using rule 27 (stmt -> declaration .)
    IDVAR           reduce using rule 27 (stmt -> declaration .)
    INTVR           reduce using rule 27 (stmt -> declaration .)
    STRNG           reduce using rule 27 (stmt -> declaration .)
    TRUE            reduce using rule 27 (stmt -> declaration .)
    FALSE           reduce using rule 27 (stmt -> declaration .)
    LET             reduce using rule 27 (stmt -> declaration .)
    CONST           reduce using rule 27 (stmt -> declaration .)
    STATIC          reduce using rule 27 (stmt -> declaration .)
    FN              reduce using rule 27 (stmt -> declaration .)
    RBCKT           reduce using rule 27 (stmt -> declaration .)
    CLOSP           reduce using rule 27 (stmt -> declaration .)


state 70

    (28) stmt -> selectionStmt .

    IF              reduce using rule 28 (stmt -> selectionStmt .)
    FOR             reduce using rule 28 (stmt -> selectionStmt .)
    WHILE           reduce using rule 28 (stmt -> selectionStmt .)
    STDIN           reduce using rule 28 (stmt -> selectionStmt .)
    PRINTLN         reduce using rule 28 (stmt -> selectionStmt .)
    IDVAR           reduce using rule 28 (stmt -> selectionStmt .)
    INTVR           reduce using rule 28 (stmt -> selectionStmt .)
    STRNG           reduce using rule 28 (stmt -> selectionStmt .)
    TRUE            reduce using rule 28 (stmt -> selectionStmt .)
    FALSE           reduce using rule 28 (stmt -> selectionStmt .)
    LET             reduce using rule 28 (stmt -> selectionStmt .)
    CONST           reduce using rule 28 (stmt -> selectionStmt .)
    STATIC          reduce using rule 28 (stmt -> selectionStmt .)
    FN              reduce using rule 28 (stmt -> selectionStmt .)
    RBCKT           reduce using rule 28 (stmt -> selectionStmt .)
    CLOSP           reduce using rule 28 (stmt -> selectionStmt .)


state 71

    (29) stmt -> iterationStmt .

    IF              reduce using rule 29 (stmt -> iterationStmt .)
    FOR             reduce using rule 29 (stmt -> iterationStmt .)
    WHILE           reduce using rule 29 (stmt -> iterationStmt .)
    STDIN           reduce using rule 29 (stmt -> iterationStmt .)
    PRINTLN         reduce using rule 29 (stmt -> iterationStmt .)
    IDVAR           reduce using rule 29 (stmt -> iterationStmt .)
    INTVR           reduce using rule 29 (stmt -> iterationStmt .)
    STRNG           reduce using rule 29 (stmt -> iterationStmt .)
    TRUE            reduce using rule 29 (stmt -> iterationStmt .)
    FALSE           reduce using rule 29 (stmt -> iterationStmt .)
    LET             reduce using rule 29 (stmt -> iterationStmt .)
    CONST           reduce using rule 29 (stmt -> iterationStmt .)
    STATIC          reduce using rule 29 (stmt -> iterationStmt .)
    FN              reduce using rule 29 (stmt -> iterationStmt .)
    RBCKT           reduce using rule 29 (stmt -> iterationStmt .)
    CLOSP           reduce using rule 29 (stmt -> iterationStmt .)


state 72

    (30) stmt -> inputStmt .

    IF              reduce using rule 30 (stmt -> inputStmt .)
    FOR             reduce using rule 30 (stmt -> inputStmt .)
    WHILE           reduce using rule 30 (stmt -> inputStmt .)
    STDIN           reduce using rule 30 (stmt -> inputStmt .)
    PRINTLN         reduce using rule 30 (stmt -> inputStmt .)
    IDVAR           reduce using rule 30 (stmt -> inputStmt .)
    INTVR           reduce using rule 30 (stmt -> inputStmt .)
    STRNG           reduce using rule 30 (stmt -> inputStmt .)
    TRUE            reduce using rule 30 (stmt -> inputStmt .)
    FALSE           reduce using rule 30 (stmt -> inputStmt .)
    LET             reduce using rule 30 (stmt -> inputStmt .)
    CONST           reduce using rule 30 (stmt -> inputStmt .)
    STATIC          reduce using rule 30 (stmt -> inputStmt .)
    FN              reduce using rule 30 (stmt -> inputStmt .)
    RBCKT           reduce using rule 30 (stmt -> inputStmt .)
    CLOSP           reduce using rule 30 (stmt -> inputStmt .)


state 73

    (31) stmt -> outputStmt .

    IF              reduce using rule 31 (stmt -> outputStmt .)
    FOR             reduce using rule 31 (stmt -> outputStmt .)
    WHILE           reduce using rule 31 (stmt -> outputStmt .)
    STDIN           reduce using rule 31 (stmt -> outputStmt .)
    PRINTLN         reduce using rule 31 (stmt -> outputStmt .)
    IDVAR           reduce using rule 31 (stmt -> outputStmt .)
    INTVR           reduce using rule 31 (stmt -> outputStmt .)
    STRNG           reduce using rule 31 (stmt -> outputStmt .)
    TRUE            reduce using rule 31 (stmt -> outputStmt .)
    FALSE           reduce using rule 31 (stmt -> outputStmt .)
    LET             reduce using rule 31 (stmt -> outputStmt .)
    CONST           reduce using rule 31 (stmt -> outputStmt .)
    STATIC          reduce using rule 31 (stmt -> outputStmt .)
    FN              reduce using rule 31 (stmt -> outputStmt .)
    RBCKT           reduce using rule 31 (stmt -> outputStmt .)
    CLOSP           reduce using rule 31 (stmt -> outputStmt .)


state 74

    (58) selectionStmt -> IF . expression EQUAL block
    (59) selectionStmt -> IF . expression EQUAL block ELSE
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 92
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 75

    (60) iterationStmt -> FOR . expression IN expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 93
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 76

    (61) iterationStmt -> WHILE . expression EQUAL expression
    (62) iterationStmt -> WHILE . expression LESST expression
    (63) iterationStmt -> WHILE . expression GREAT expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 94
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 77

    (64) inputStmt -> STDIN . OPENP stmt CLOSP

    OPENP           shift and go to state 95


state 78

    (65) outputStmt -> PRINTLN . OPENP stmt CLOSP

    OPENP           shift and go to state 96


state 79

    (36) basicExp -> IDVAR .
    (39) identifier -> IDVAR .

  ! reduce/reduce conflict for EQUAL resolved using rule 36 (basicExp -> IDVAR .)
    LESST           reduce using rule 36 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 36 (basicExp -> IDVAR .)
    GREAT           reduce using rule 36 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 36 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 36 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 36 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 36 (basicExp -> IDVAR .)
    IF              reduce using rule 36 (basicExp -> IDVAR .)
    FOR             reduce using rule 36 (basicExp -> IDVAR .)
    WHILE           reduce using rule 36 (basicExp -> IDVAR .)
    STDIN           reduce using rule 36 (basicExp -> IDVAR .)
    PRINTLN         reduce using rule 36 (basicExp -> IDVAR .)
    IDVAR           reduce using rule 36 (basicExp -> IDVAR .)
    INTVR           reduce using rule 36 (basicExp -> IDVAR .)
    STRNG           reduce using rule 36 (basicExp -> IDVAR .)
    TRUE            reduce using rule 36 (basicExp -> IDVAR .)
    FALSE           reduce using rule 36 (basicExp -> IDVAR .)
    LET             reduce using rule 36 (basicExp -> IDVAR .)
    CONST           reduce using rule 36 (basicExp -> IDVAR .)
    STATIC          reduce using rule 36 (basicExp -> IDVAR .)
    FN              reduce using rule 36 (basicExp -> IDVAR .)
    RBCKT           reduce using rule 36 (basicExp -> IDVAR .)
    SEMCL           reduce using rule 36 (basicExp -> IDVAR .)
    IN              reduce using rule 36 (basicExp -> IDVAR .)
    CLOSP           reduce using rule 36 (basicExp -> IDVAR .)
    ADDOP           reduce using rule 39 (identifier -> IDVAR .)
    SUBOP           reduce using rule 39 (identifier -> IDVAR .)
    DEROP           reduce using rule 39 (identifier -> IDVAR .)
    QUOOP           reduce using rule 39 (identifier -> IDVAR .)
    REMOP           reduce using rule 39 (identifier -> IDVAR .)

  ! EQUAL           [ reduce using rule 39 (identifier -> IDVAR .) ]


state 80

    (37) basicExp -> INTVR .
    (40) identifier -> INTVR .

  ! reduce/reduce conflict for EQUAL resolved using rule 37 (basicExp -> INTVR .)
    LESST           reduce using rule 37 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 37 (basicExp -> INTVR .)
    GREAT           reduce using rule 37 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 37 (basicExp -> INTVR .)
    EQUAL           reduce using rule 37 (basicExp -> INTVR .)
    UNEQL           reduce using rule 37 (basicExp -> INTVR .)
    EQLTO           reduce using rule 37 (basicExp -> INTVR .)
    IF              reduce using rule 37 (basicExp -> INTVR .)
    FOR             reduce using rule 37 (basicExp -> INTVR .)
    WHILE           reduce using rule 37 (basicExp -> INTVR .)
    STDIN           reduce using rule 37 (basicExp -> INTVR .)
    PRINTLN         reduce using rule 37 (basicExp -> INTVR .)
    IDVAR           reduce using rule 37 (basicExp -> INTVR .)
    INTVR           reduce using rule 37 (basicExp -> INTVR .)
    STRNG           reduce using rule 37 (basicExp -> INTVR .)
    TRUE            reduce using rule 37 (basicExp -> INTVR .)
    FALSE           reduce using rule 37 (basicExp -> INTVR .)
    LET             reduce using rule 37 (basicExp -> INTVR .)
    CONST           reduce using rule 37 (basicExp -> INTVR .)
    STATIC          reduce using rule 37 (basicExp -> INTVR .)
    FN              reduce using rule 37 (basicExp -> INTVR .)
    RBCKT           reduce using rule 37 (basicExp -> INTVR .)
    SEMCL           reduce using rule 37 (basicExp -> INTVR .)
    IN              reduce using rule 37 (basicExp -> INTVR .)
    CLOSP           reduce using rule 37 (basicExp -> INTVR .)
    ADDOP           reduce using rule 40 (identifier -> INTVR .)
    SUBOP           reduce using rule 40 (identifier -> INTVR .)
    DEROP           reduce using rule 40 (identifier -> INTVR .)
    QUOOP           reduce using rule 40 (identifier -> INTVR .)
    REMOP           reduce using rule 40 (identifier -> INTVR .)

  ! EQUAL           [ reduce using rule 40 (identifier -> INTVR .) ]


state 81

    (38) basicExp -> STRNG .

    LESST           reduce using rule 38 (basicExp -> STRNG .)
    LSSEQ           reduce using rule 38 (basicExp -> STRNG .)
    GREAT           reduce using rule 38 (basicExp -> STRNG .)
    GRTEQ           reduce using rule 38 (basicExp -> STRNG .)
    EQUAL           reduce using rule 38 (basicExp -> STRNG .)
    UNEQL           reduce using rule 38 (basicExp -> STRNG .)
    EQLTO           reduce using rule 38 (basicExp -> STRNG .)
    IF              reduce using rule 38 (basicExp -> STRNG .)
    FOR             reduce using rule 38 (basicExp -> STRNG .)
    WHILE           reduce using rule 38 (basicExp -> STRNG .)
    STDIN           reduce using rule 38 (basicExp -> STRNG .)
    PRINTLN         reduce using rule 38 (basicExp -> STRNG .)
    IDVAR           reduce using rule 38 (basicExp -> STRNG .)
    INTVR           reduce using rule 38 (basicExp -> STRNG .)
    STRNG           reduce using rule 38 (basicExp -> STRNG .)
    TRUE            reduce using rule 38 (basicExp -> STRNG .)
    FALSE           reduce using rule 38 (basicExp -> STRNG .)
    LET             reduce using rule 38 (basicExp -> STRNG .)
    CONST           reduce using rule 38 (basicExp -> STRNG .)
    STATIC          reduce using rule 38 (basicExp -> STRNG .)
    FN              reduce using rule 38 (basicExp -> STRNG .)
    RBCKT           reduce using rule 38 (basicExp -> STRNG .)
    SEMCL           reduce using rule 38 (basicExp -> STRNG .)
    IN              reduce using rule 38 (basicExp -> STRNG .)
    CLOSP           reduce using rule 38 (basicExp -> STRNG .)


state 82

    (18) parameters -> OPENP paramList CLOSP .

    LBCKT           reduce using rule 18 (parameters -> OPENP paramList CLOSP .)


state 83

    (20) paramList -> parameter COMMA . paramList
    (19) paramList -> . parameter
    (20) paramList -> . parameter COMMA paramList
    (21) parameter -> . IDVAR

    IDVAR           shift and go to state 42

    parameter                      shift and go to state 41
    paramList                      shift and go to state 97

state 84

    (43) comparisonExp -> basicExp relop basicExp .
    (43) comparisonExp -> basicExp . relop basicExp
    (44) comparisonExp -> basicExp . relop comparisonExp
    (45) relop -> . LESST
    (46) relop -> . LSSEQ
    (47) relop -> . GREAT
    (48) relop -> . GRTEQ
    (49) relop -> . EQUAL
    (50) relop -> . UNEQL
    (51) relop -> . EQLTO

  ! shift/reduce conflict for LESST resolved as shift
  ! shift/reduce conflict for GREAT resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
    SEMCL           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    IF              reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    FOR             reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    WHILE           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    STDIN           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    PRINTLN         reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    IDVAR           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    INTVR           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    STRNG           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    TRUE            reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    FALSE           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    LET             reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    CONST           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    STATIC          reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    FN              reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    RBCKT           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    IN              reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    CLOSP           reduce using rule 43 (comparisonExp -> basicExp relop basicExp .)
    LESST           shift and go to state 48
    LSSEQ           shift and go to state 49
    GREAT           shift and go to state 50
    GRTEQ           shift and go to state 51
    EQUAL           shift and go to state 52
    UNEQL           shift and go to state 53
    EQLTO           shift and go to state 54

  ! EQUAL           [ reduce using rule 43 (comparisonExp -> basicExp relop basicExp .) ]
  ! LESST           [ reduce using rule 43 (comparisonExp -> basicExp relop basicExp .) ]
  ! GREAT           [ reduce using rule 43 (comparisonExp -> basicExp relop basicExp .) ]

    relop                          shift and go to state 47

state 85

    (44) comparisonExp -> basicExp relop comparisonExp .

    SEMCL           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    IF              reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    FOR             reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    WHILE           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    STDIN           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    PRINTLN         reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    IDVAR           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    INTVR           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    STRNG           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    TRUE            reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    FALSE           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    LET             reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    CONST           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    STATIC          reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    FN              reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    RBCKT           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    EQUAL           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    IN              reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    LESST           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    GREAT           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)
    CLOSP           reduce using rule 44 (comparisonExp -> basicExp relop comparisonExp .)


state 86

    (36) basicExp -> IDVAR .

    LESST           reduce using rule 36 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 36 (basicExp -> IDVAR .)
    GREAT           reduce using rule 36 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 36 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 36 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 36 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 36 (basicExp -> IDVAR .)
    SEMCL           reduce using rule 36 (basicExp -> IDVAR .)
    IF              reduce using rule 36 (basicExp -> IDVAR .)
    FOR             reduce using rule 36 (basicExp -> IDVAR .)
    WHILE           reduce using rule 36 (basicExp -> IDVAR .)
    STDIN           reduce using rule 36 (basicExp -> IDVAR .)
    PRINTLN         reduce using rule 36 (basicExp -> IDVAR .)
    IDVAR           reduce using rule 36 (basicExp -> IDVAR .)
    INTVR           reduce using rule 36 (basicExp -> IDVAR .)
    STRNG           reduce using rule 36 (basicExp -> IDVAR .)
    TRUE            reduce using rule 36 (basicExp -> IDVAR .)
    FALSE           reduce using rule 36 (basicExp -> IDVAR .)
    LET             reduce using rule 36 (basicExp -> IDVAR .)
    CONST           reduce using rule 36 (basicExp -> IDVAR .)
    STATIC          reduce using rule 36 (basicExp -> IDVAR .)
    FN              reduce using rule 36 (basicExp -> IDVAR .)
    RBCKT           reduce using rule 36 (basicExp -> IDVAR .)
    IN              reduce using rule 36 (basicExp -> IDVAR .)
    CLOSP           reduce using rule 36 (basicExp -> IDVAR .)


state 87

    (37) basicExp -> INTVR .

    LESST           reduce using rule 37 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 37 (basicExp -> INTVR .)
    GREAT           reduce using rule 37 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 37 (basicExp -> INTVR .)
    EQUAL           reduce using rule 37 (basicExp -> INTVR .)
    UNEQL           reduce using rule 37 (basicExp -> INTVR .)
    EQLTO           reduce using rule 37 (basicExp -> INTVR .)
    SEMCL           reduce using rule 37 (basicExp -> INTVR .)
    IF              reduce using rule 37 (basicExp -> INTVR .)
    FOR             reduce using rule 37 (basicExp -> INTVR .)
    WHILE           reduce using rule 37 (basicExp -> INTVR .)
    STDIN           reduce using rule 37 (basicExp -> INTVR .)
    PRINTLN         reduce using rule 37 (basicExp -> INTVR .)
    IDVAR           reduce using rule 37 (basicExp -> INTVR .)
    INTVR           reduce using rule 37 (basicExp -> INTVR .)
    STRNG           reduce using rule 37 (basicExp -> INTVR .)
    TRUE            reduce using rule 37 (basicExp -> INTVR .)
    FALSE           reduce using rule 37 (basicExp -> INTVR .)
    LET             reduce using rule 37 (basicExp -> INTVR .)
    CONST           reduce using rule 37 (basicExp -> INTVR .)
    STATIC          reduce using rule 37 (basicExp -> INTVR .)
    FN              reduce using rule 37 (basicExp -> INTVR .)
    RBCKT           reduce using rule 37 (basicExp -> INTVR .)
    IN              reduce using rule 37 (basicExp -> INTVR .)
    CLOSP           reduce using rule 37 (basicExp -> INTVR .)


state 88

    (41) assignmentExp -> identifier sumOp basicExp .

    SEMCL           reduce using rule 41 (assignmentExp -> identifier sumOp basicExp .)


state 89

    (42) assignmentExp -> identifier sumOp assignmentExp .

    SEMCL           reduce using rule 42 (assignmentExp -> identifier sumOp assignmentExp .)


state 90

    (23) block -> LBCKT statement-list RBCKT .

    LET             reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    CONST           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    STATIC          reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    FN              reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    $end            reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    IF              reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    FOR             reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    WHILE           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    STDIN           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    PRINTLN         reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    IDVAR           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    INTVR           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    STRNG           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    TRUE            reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    FALSE           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    RBCKT           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    CLOSP           reduce using rule 23 (block -> LBCKT statement-list RBCKT .)
    ELSE            reduce using rule 23 (block -> LBCKT statement-list RBCKT .)


state 91

    (25) statement-list -> stmt statement-list .

    RBCKT           reduce using rule 25 (statement-list -> stmt statement-list .)


state 92

    (58) selectionStmt -> IF expression . EQUAL block
    (59) selectionStmt -> IF expression . EQUAL block ELSE

    EQUAL           shift and go to state 98


state 93

    (60) iterationStmt -> FOR expression . IN expression

    IN              shift and go to state 99


state 94

    (61) iterationStmt -> WHILE expression . EQUAL expression
    (62) iterationStmt -> WHILE expression . LESST expression
    (63) iterationStmt -> WHILE expression . GREAT expression

    EQUAL           shift and go to state 100
    LESST           shift and go to state 101
    GREAT           shift and go to state 102


state 95

    (64) inputStmt -> STDIN OPENP . stmt CLOSP
    (26) stmt -> . expression
    (27) stmt -> . declaration
    (28) stmt -> . selectionStmt
    (29) stmt -> . iterationStmt
    (30) stmt -> . inputStmt
    (31) stmt -> . outputStmt
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (58) selectionStmt -> . IF expression EQUAL block
    (59) selectionStmt -> . IF expression EQUAL block ELSE
    (60) iterationStmt -> . FOR expression IN expression
    (61) iterationStmt -> . WHILE expression EQUAL expression
    (62) iterationStmt -> . WHILE expression LESST expression
    (63) iterationStmt -> . WHILE expression GREAT expression
    (64) inputStmt -> . STDIN OPENP stmt CLOSP
    (65) outputStmt -> . PRINTLN OPENP stmt CLOSP
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IF              shift and go to state 74
    FOR             shift and go to state 75
    WHILE           shift and go to state 76
    STDIN           shift and go to state 77
    PRINTLN         shift and go to state 78
    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    stmt                           shift and go to state 103
    expression                     shift and go to state 68
    declaration                    shift and go to state 69
    selectionStmt                  shift and go to state 70
    iterationStmt                  shift and go to state 71
    inputStmt                      shift and go to state 72
    outputStmt                     shift and go to state 73
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8
    identifier                     shift and go to state 32

state 96

    (65) outputStmt -> PRINTLN OPENP . stmt CLOSP
    (26) stmt -> . expression
    (27) stmt -> . declaration
    (28) stmt -> . selectionStmt
    (29) stmt -> . iterationStmt
    (30) stmt -> . inputStmt
    (31) stmt -> . outputStmt
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (5) declaration -> . varDeclaration
    (6) declaration -> . constDeclaration
    (7) declaration -> . staticDeclaration
    (8) declaration -> . funcDeclaration
    (58) selectionStmt -> . IF expression EQUAL block
    (59) selectionStmt -> . IF expression EQUAL block ELSE
    (60) iterationStmt -> . FOR expression IN expression
    (61) iterationStmt -> . WHILE expression EQUAL expression
    (62) iterationStmt -> . WHILE expression LESST expression
    (63) iterationStmt -> . WHILE expression GREAT expression
    (64) inputStmt -> . STDIN OPENP stmt CLOSP
    (65) outputStmt -> . PRINTLN OPENP stmt CLOSP
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (9) varDeclaration -> . LET IDVAR EQUAL IDVAR SEMCL
    (10) varDeclaration -> . LET IDVAR EQUAL INTVR SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL STRNG SEMCL
    (12) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (13) constDeclaration -> . CONST IDVAR EQUAL IDVAR SEMCL
    (14) staticDeclaration -> . STATIC IDVAR EQUAL IDVAR SEMCL
    (15) funcDeclaration -> . FN function
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IF              shift and go to state 74
    FOR             shift and go to state 75
    WHILE           shift and go to state 76
    STDIN           shift and go to state 77
    PRINTLN         shift and go to state 78
    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 9
    CONST           shift and go to state 10
    STATIC          shift and go to state 11
    FN              shift and go to state 12

    stmt                           shift and go to state 104
    expression                     shift and go to state 68
    declaration                    shift and go to state 69
    selectionStmt                  shift and go to state 70
    iterationStmt                  shift and go to state 71
    inputStmt                      shift and go to state 72
    outputStmt                     shift and go to state 73
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    varDeclaration                 shift and go to state 5
    constDeclaration               shift and go to state 6
    staticDeclaration              shift and go to state 7
    funcDeclaration                shift and go to state 8
    identifier                     shift and go to state 32

state 97

    (20) paramList -> parameter COMMA paramList .

    CLOSP           reduce using rule 20 (paramList -> parameter COMMA paramList .)


state 98

    (58) selectionStmt -> IF expression EQUAL . block
    (59) selectionStmt -> IF expression EQUAL . block ELSE
    (22) block -> . LBCKT RBCKT
    (23) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 38

    block                          shift and go to state 105

state 99

    (60) iterationStmt -> FOR expression IN . expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 106
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 100

    (61) iterationStmt -> WHILE expression EQUAL . expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 107
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 101

    (62) iterationStmt -> WHILE expression LESST . expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 108
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 102

    (63) iterationStmt -> WHILE expression GREAT . expression
    (32) expression -> . basicExp
    (33) expression -> . assignmentExp SEMCL
    (34) expression -> . comparisonExp
    (35) expression -> . boolExp
    (36) basicExp -> . IDVAR
    (37) basicExp -> . INTVR
    (38) basicExp -> . STRNG
    (41) assignmentExp -> . identifier sumOp basicExp
    (42) assignmentExp -> . identifier sumOp assignmentExp
    (43) comparisonExp -> . basicExp relop basicExp
    (44) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (39) identifier -> . IDVAR
    (40) identifier -> . INTVR

    IDVAR           shift and go to state 79
    INTVR           shift and go to state 80
    STRNG           shift and go to state 81
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 109
    basicExp                       shift and go to state 28
    assignmentExp                  shift and go to state 29
    comparisonExp                  shift and go to state 30
    boolExp                        shift and go to state 31
    identifier                     shift and go to state 32

state 103

    (64) inputStmt -> STDIN OPENP stmt . CLOSP

    CLOSP           shift and go to state 110


state 104

    (65) outputStmt -> PRINTLN OPENP stmt . CLOSP

    CLOSP           shift and go to state 111


state 105

    (58) selectionStmt -> IF expression EQUAL block .
    (59) selectionStmt -> IF expression EQUAL block . ELSE

    IF              reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    FOR             reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    WHILE           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    STDIN           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    PRINTLN         reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    IDVAR           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    INTVR           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    STRNG           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    TRUE            reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    FALSE           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    LET             reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    CONST           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    STATIC          reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    FN              reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    RBCKT           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    CLOSP           reduce using rule 58 (selectionStmt -> IF expression EQUAL block .)
    ELSE            shift and go to state 112


state 106

    (60) iterationStmt -> FOR expression IN expression .

    IF              reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    FOR             reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    WHILE           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    STDIN           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    PRINTLN         reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    IDVAR           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    INTVR           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    STRNG           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    TRUE            reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    FALSE           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    LET             reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    CONST           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    STATIC          reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    FN              reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    RBCKT           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)
    CLOSP           reduce using rule 60 (iterationStmt -> FOR expression IN expression .)


state 107

    (61) iterationStmt -> WHILE expression EQUAL expression .

    IF              reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    FOR             reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    WHILE           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    STDIN           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    PRINTLN         reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    IDVAR           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    INTVR           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    STRNG           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    TRUE            reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    FALSE           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    LET             reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    CONST           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    STATIC          reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    FN              reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    RBCKT           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)
    CLOSP           reduce using rule 61 (iterationStmt -> WHILE expression EQUAL expression .)


state 108

    (62) iterationStmt -> WHILE expression LESST expression .

    IF              reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    FOR             reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    WHILE           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    STDIN           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    PRINTLN         reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    IDVAR           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    INTVR           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    STRNG           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    TRUE            reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    FALSE           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    LET             reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    CONST           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    STATIC          reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    FN              reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    RBCKT           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)
    CLOSP           reduce using rule 62 (iterationStmt -> WHILE expression LESST expression .)


state 109

    (63) iterationStmt -> WHILE expression GREAT expression .

    IF              reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    FOR             reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    WHILE           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    STDIN           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    PRINTLN         reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    IDVAR           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    INTVR           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    STRNG           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    TRUE            reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    FALSE           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    LET             reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    CONST           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    STATIC          reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    FN              reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    RBCKT           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)
    CLOSP           reduce using rule 63 (iterationStmt -> WHILE expression GREAT expression .)


state 110

    (64) inputStmt -> STDIN OPENP stmt CLOSP .

    IF              reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    FOR             reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    WHILE           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    STDIN           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    PRINTLN         reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    IDVAR           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    INTVR           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    STRNG           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    TRUE            reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    FALSE           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    LET             reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    CONST           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    STATIC          reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    FN              reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    RBCKT           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)
    CLOSP           reduce using rule 64 (inputStmt -> STDIN OPENP stmt CLOSP .)


state 111

    (65) outputStmt -> PRINTLN OPENP stmt CLOSP .

    IF              reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    FOR             reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    WHILE           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    STDIN           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    PRINTLN         reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    IDVAR           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    INTVR           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    STRNG           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    TRUE            reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    FALSE           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    LET             reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    CONST           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    STATIC          reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    FN              reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    RBCKT           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)
    CLOSP           reduce using rule 65 (outputStmt -> PRINTLN OPENP stmt CLOSP .)


state 112

    (59) selectionStmt -> IF expression EQUAL block ELSE .

    IF              reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    FOR             reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    WHILE           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    STDIN           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    PRINTLN         reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    IDVAR           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    INTVR           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    STRNG           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    TRUE            reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    FALSE           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    LET             reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    CONST           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    STATIC          reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    FN              reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    RBCKT           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)
    CLOSP           reduce using rule 59 (selectionStmt -> IF expression EQUAL block ELSE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMCL in state 24 resolved as shift
WARNING: shift/reduce conflict for SEMCL in state 25 resolved as shift
WARNING: shift/reduce conflict for SEMCL in state 26 resolved as shift
WARNING: shift/reduce conflict for LESST in state 28 resolved as shift
WARNING: shift/reduce conflict for GREAT in state 28 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 28 resolved as shift
WARNING: shift/reduce conflict for LESST in state 84 resolved as shift
WARNING: shift/reduce conflict for GREAT in state 84 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 84 resolved as shift
WARNING: reduce/reduce conflict in state 24 resolved using rule (basicExp -> IDVAR)
WARNING: rejected rule (identifier -> IDVAR) in state 24
WARNING: reduce/reduce conflict in state 25 resolved using rule (basicExp -> INTVR)
WARNING: rejected rule (identifier -> INTVR) in state 25
WARNING: reduce/reduce conflict in state 79 resolved using rule (basicExp -> IDVAR)
WARNING: rejected rule (identifier -> IDVAR) in state 79
WARNING: reduce/reduce conflict in state 80 resolved using rule (basicExp -> INTVR)
WARNING: rejected rule (identifier -> INTVR) in state 80
