Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    POWER
    COMPA
    ANDOP
    OROPE
    SLCOM
    BLCOM
    DOTOP
    COLON
    INPUT
    OUTPT

Grammar

Rule 0     S' -> foo
Rule 1     foo -> program
Rule 2     program -> declarationList
Rule 3     program -> statement-list
Rule 4     declarationList -> declaration
Rule 5     declarationList -> declaration declarationList
Rule 6     declaration -> varDeclaration
Rule 7     declaration -> constDeclaration
Rule 8     declaration -> staticDeclaration
Rule 9     declaration -> funcDeclaration
Rule 10    varDeclaration -> LET IDVAR EQUAL expression SEMCL
Rule 11    varDeclaration -> LET IDVAR EQUAL identifier SEMCL
Rule 12    constDeclaration -> CONST IDVAR EQUAL expression SEMCL
Rule 13    staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL
Rule 14    funcDeclaration -> FN function
Rule 15    function -> IDVAR parameters block
Rule 16    parameters -> OPENP CLOSP
Rule 17    parameters -> OPENP paramList CLOSP
Rule 18    parameters -> OPENP expression CLOSP
Rule 19    paramList -> parameter
Rule 20    paramList -> parameter COMMA paramList
Rule 21    parameter -> IDVAR
Rule 22    parameter -> INTVR
Rule 23    parameter -> STRNG
Rule 24    block -> LBCKT RBCKT
Rule 25    block -> LBCKT statement-list RBCKT
Rule 26    statement-list -> stmt
Rule 27    statement-list -> stmt statement-list
Rule 28    inputStmt -> STDIN OPENP stmt CLOSP SEMCL
Rule 29    outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL
Rule 30    stmt -> expression
Rule 31    stmt -> declaration
Rule 32    stmt -> selectionStmt
Rule 33    stmt -> iterationStmt
Rule 34    stmt -> inputStmt
Rule 35    stmt -> outputStmt
Rule 36    expression -> basicExp
Rule 37    expression -> assignmentExp SEMCL
Rule 38    expression -> comparisonExp
Rule 39    expression -> boolExp
Rule 40    basicExp -> INTVR
Rule 41    basicExp -> STRNG
Rule 42    basicExp -> IDVAR
Rule 43    assignmentExp -> identifier sumOp basicExp
Rule 44    assignmentExp -> identifier sumOp assignmentExp
Rule 45    identifier -> IDVAR
Rule 46    identifier -> INTVR
Rule 47    comparisonExp -> basicExp relop basicExp
Rule 48    comparisonExp -> basicExp relop comparisonExp
Rule 49    relop -> LESST
Rule 50    relop -> LSSEQ
Rule 51    relop -> GREAT
Rule 52    relop -> GRTEQ
Rule 53    relop -> EQUAL
Rule 54    relop -> UNEQL
Rule 55    relop -> EQLTO
Rule 56    sumOp -> ADDOP
Rule 57    sumOp -> SUBOP
Rule 58    sumOp -> DEROP
Rule 59    sumOp -> QUOOP
Rule 60    sumOp -> EQUAL
Rule 61    sumOp -> REMOP
Rule 62    selectionStmt -> IF OPENP expression CLOSP block
Rule 63    selectionStmt -> IF OPENP expression CLOSP block ELSE block
Rule 64    iterationStmt -> FOR expression IN expression
Rule 65    iterationStmt -> WHILE parameters block
Rule 66    boolExp -> TRUE
Rule 67    boolExp -> FALSE

Terminals, with rules where they appear

ADDOP                : 56
ANDOP                : 
BLCOM                : 
CLOSP                : 16 17 18 28 29 62 63
COLON                : 
COMMA                : 20
COMPA                : 
CONST                : 12
DEROP                : 58
DOTOP                : 
ELSE                 : 63
EQLTO                : 55
EQUAL                : 10 11 12 13 53 60
FALSE                : 67
FN                   : 14
FOR                  : 64
GREAT                : 51
GRTEQ                : 52
IDVAR                : 10 11 12 13 15 21 42 45
IF                   : 62 63
IN                   : 64
INPUT                : 
INTVR                : 22 40 46
LBCKT                : 24 25
LESST                : 49
LET                  : 10 11
LSSEQ                : 50
OPENP                : 16 17 18 28 29 62 63
OROPE                : 
OUTPT                : 
POWER                : 
PRINTLN              : 29
QUOOP                : 59
RBCKT                : 24 25
REMOP                : 61
SEMCL                : 10 11 12 13 28 29 37
SLCOM                : 
STATIC               : 13
STDIN                : 28
STRNG                : 23 41
SUBOP                : 57
TRUE                 : 66
UNEQL                : 54
WHILE                : 65
error                : 

Nonterminals, with rules where they appear

assignmentExp        : 37 44
basicExp             : 36 43 47 47 48
block                : 15 62 63 63 65
boolExp              : 39
comparisonExp        : 38 48
constDeclaration     : 7
declaration          : 4 5 31
declarationList      : 2 5
expression           : 10 12 13 18 30 62 63 64 64
foo                  : 0
funcDeclaration      : 9
function             : 14
identifier           : 11 43 44
inputStmt            : 34
iterationStmt        : 33
outputStmt           : 35
paramList            : 17 20
parameter            : 19 20
parameters           : 15 65
program              : 1
relop                : 47 48
selectionStmt        : 32
statement-list       : 3 25 27
staticDeclaration    : 8
stmt                 : 26 27 28 29
sumOp                : 43 44
varDeclaration       : 6

Parsing method: LALR

state 0

    (0) S' -> . foo
    (1) foo -> . program
    (2) program -> . declarationList
    (3) program -> . statement-list
    (4) declarationList -> . declaration
    (5) declarationList -> . declaration declarationList
    (26) statement-list -> . stmt
    (27) statement-list -> . stmt statement-list
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (30) stmt -> . expression
    (31) stmt -> . declaration
    (32) stmt -> . selectionStmt
    (33) stmt -> . iterationStmt
    (34) stmt -> . inputStmt
    (35) stmt -> . outputStmt
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (62) selectionStmt -> . IF OPENP expression CLOSP block
    (63) selectionStmt -> . IF OPENP expression CLOSP block ELSE block
    (64) iterationStmt -> . FOR expression IN expression
    (65) iterationStmt -> . WHILE parameters block
    (28) inputStmt -> . STDIN OPENP stmt CLOSP SEMCL
    (29) outputStmt -> . PRINTLN OPENP stmt CLOSP SEMCL
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21
    IF              shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    STDIN           shift and go to state 29
    PRINTLN         shift and go to state 30
    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    foo                            shift and go to state 1
    program                        shift and go to state 2
    declarationList                shift and go to state 3
    statement-list                 shift and go to state 4
    declaration                    shift and go to state 5
    stmt                           shift and go to state 6
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10
    expression                     shift and go to state 11
    selectionStmt                  shift and go to state 12
    iterationStmt                  shift and go to state 13
    inputStmt                      shift and go to state 14
    outputStmt                     shift and go to state 15
    identifier                     shift and go to state 18
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25

state 1

    (0) S' -> foo .



state 2

    (1) foo -> program .

    $end            reduce using rule 1 (foo -> program .)


state 3

    (2) program -> declarationList .

    $end            reduce using rule 2 (program -> declarationList .)


state 4

    (3) program -> statement-list .

    $end            reduce using rule 3 (program -> statement-list .)


state 5

    (4) declarationList -> declaration .
    (5) declarationList -> declaration . declarationList
    (31) stmt -> declaration .
    (4) declarationList -> . declaration
    (5) declarationList -> . declaration declarationList
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function

  ! reduce/reduce conflict for $end resolved using rule 4 (declarationList -> declaration .)
  ! shift/reduce conflict for LET resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for FN resolved as shift
    $end            reduce using rule 4 (declarationList -> declaration .)
    IF              reduce using rule 31 (stmt -> declaration .)
    FOR             reduce using rule 31 (stmt -> declaration .)
    WHILE           reduce using rule 31 (stmt -> declaration .)
    STDIN           reduce using rule 31 (stmt -> declaration .)
    PRINTLN         reduce using rule 31 (stmt -> declaration .)
    INTVR           reduce using rule 31 (stmt -> declaration .)
    STRNG           reduce using rule 31 (stmt -> declaration .)
    IDVAR           reduce using rule 31 (stmt -> declaration .)
    TRUE            reduce using rule 31 (stmt -> declaration .)
    FALSE           reduce using rule 31 (stmt -> declaration .)
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

  ! LET             [ reduce using rule 31 (stmt -> declaration .) ]
  ! CONST           [ reduce using rule 31 (stmt -> declaration .) ]
  ! STATIC          [ reduce using rule 31 (stmt -> declaration .) ]
  ! FN              [ reduce using rule 31 (stmt -> declaration .) ]
  ! $end            [ reduce using rule 31 (stmt -> declaration .) ]

    declaration                    shift and go to state 35
    declarationList                shift and go to state 36
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10

state 6

    (26) statement-list -> stmt .
    (27) statement-list -> stmt . statement-list
    (26) statement-list -> . stmt
    (27) statement-list -> . stmt statement-list
    (30) stmt -> . expression
    (31) stmt -> . declaration
    (32) stmt -> . selectionStmt
    (33) stmt -> . iterationStmt
    (34) stmt -> . inputStmt
    (35) stmt -> . outputStmt
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (62) selectionStmt -> . IF OPENP expression CLOSP block
    (63) selectionStmt -> . IF OPENP expression CLOSP block ELSE block
    (64) iterationStmt -> . FOR expression IN expression
    (65) iterationStmt -> . WHILE parameters block
    (28) inputStmt -> . STDIN OPENP stmt CLOSP SEMCL
    (29) outputStmt -> . PRINTLN OPENP stmt CLOSP SEMCL
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    $end            reduce using rule 26 (statement-list -> stmt .)
    RBCKT           reduce using rule 26 (statement-list -> stmt .)
    IF              shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    STDIN           shift and go to state 29
    PRINTLN         shift and go to state 30
    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

    stmt                           shift and go to state 6
    statement-list                 shift and go to state 37
    expression                     shift and go to state 11
    declaration                    shift and go to state 38
    selectionStmt                  shift and go to state 12
    iterationStmt                  shift and go to state 13
    inputStmt                      shift and go to state 14
    outputStmt                     shift and go to state 15
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10
    identifier                     shift and go to state 18

state 7

    (6) declaration -> varDeclaration .

    LET             reduce using rule 6 (declaration -> varDeclaration .)
    CONST           reduce using rule 6 (declaration -> varDeclaration .)
    STATIC          reduce using rule 6 (declaration -> varDeclaration .)
    FN              reduce using rule 6 (declaration -> varDeclaration .)
    $end            reduce using rule 6 (declaration -> varDeclaration .)
    IF              reduce using rule 6 (declaration -> varDeclaration .)
    FOR             reduce using rule 6 (declaration -> varDeclaration .)
    WHILE           reduce using rule 6 (declaration -> varDeclaration .)
    STDIN           reduce using rule 6 (declaration -> varDeclaration .)
    PRINTLN         reduce using rule 6 (declaration -> varDeclaration .)
    INTVR           reduce using rule 6 (declaration -> varDeclaration .)
    STRNG           reduce using rule 6 (declaration -> varDeclaration .)
    IDVAR           reduce using rule 6 (declaration -> varDeclaration .)
    TRUE            reduce using rule 6 (declaration -> varDeclaration .)
    FALSE           reduce using rule 6 (declaration -> varDeclaration .)
    RBCKT           reduce using rule 6 (declaration -> varDeclaration .)
    CLOSP           reduce using rule 6 (declaration -> varDeclaration .)


state 8

    (7) declaration -> constDeclaration .

    LET             reduce using rule 7 (declaration -> constDeclaration .)
    CONST           reduce using rule 7 (declaration -> constDeclaration .)
    STATIC          reduce using rule 7 (declaration -> constDeclaration .)
    FN              reduce using rule 7 (declaration -> constDeclaration .)
    $end            reduce using rule 7 (declaration -> constDeclaration .)
    IF              reduce using rule 7 (declaration -> constDeclaration .)
    FOR             reduce using rule 7 (declaration -> constDeclaration .)
    WHILE           reduce using rule 7 (declaration -> constDeclaration .)
    STDIN           reduce using rule 7 (declaration -> constDeclaration .)
    PRINTLN         reduce using rule 7 (declaration -> constDeclaration .)
    INTVR           reduce using rule 7 (declaration -> constDeclaration .)
    STRNG           reduce using rule 7 (declaration -> constDeclaration .)
    IDVAR           reduce using rule 7 (declaration -> constDeclaration .)
    TRUE            reduce using rule 7 (declaration -> constDeclaration .)
    FALSE           reduce using rule 7 (declaration -> constDeclaration .)
    RBCKT           reduce using rule 7 (declaration -> constDeclaration .)
    CLOSP           reduce using rule 7 (declaration -> constDeclaration .)


state 9

    (8) declaration -> staticDeclaration .

    LET             reduce using rule 8 (declaration -> staticDeclaration .)
    CONST           reduce using rule 8 (declaration -> staticDeclaration .)
    STATIC          reduce using rule 8 (declaration -> staticDeclaration .)
    FN              reduce using rule 8 (declaration -> staticDeclaration .)
    $end            reduce using rule 8 (declaration -> staticDeclaration .)
    IF              reduce using rule 8 (declaration -> staticDeclaration .)
    FOR             reduce using rule 8 (declaration -> staticDeclaration .)
    WHILE           reduce using rule 8 (declaration -> staticDeclaration .)
    STDIN           reduce using rule 8 (declaration -> staticDeclaration .)
    PRINTLN         reduce using rule 8 (declaration -> staticDeclaration .)
    INTVR           reduce using rule 8 (declaration -> staticDeclaration .)
    STRNG           reduce using rule 8 (declaration -> staticDeclaration .)
    IDVAR           reduce using rule 8 (declaration -> staticDeclaration .)
    TRUE            reduce using rule 8 (declaration -> staticDeclaration .)
    FALSE           reduce using rule 8 (declaration -> staticDeclaration .)
    RBCKT           reduce using rule 8 (declaration -> staticDeclaration .)
    CLOSP           reduce using rule 8 (declaration -> staticDeclaration .)


state 10

    (9) declaration -> funcDeclaration .

    LET             reduce using rule 9 (declaration -> funcDeclaration .)
    CONST           reduce using rule 9 (declaration -> funcDeclaration .)
    STATIC          reduce using rule 9 (declaration -> funcDeclaration .)
    FN              reduce using rule 9 (declaration -> funcDeclaration .)
    $end            reduce using rule 9 (declaration -> funcDeclaration .)
    IF              reduce using rule 9 (declaration -> funcDeclaration .)
    FOR             reduce using rule 9 (declaration -> funcDeclaration .)
    WHILE           reduce using rule 9 (declaration -> funcDeclaration .)
    STDIN           reduce using rule 9 (declaration -> funcDeclaration .)
    PRINTLN         reduce using rule 9 (declaration -> funcDeclaration .)
    INTVR           reduce using rule 9 (declaration -> funcDeclaration .)
    STRNG           reduce using rule 9 (declaration -> funcDeclaration .)
    IDVAR           reduce using rule 9 (declaration -> funcDeclaration .)
    TRUE            reduce using rule 9 (declaration -> funcDeclaration .)
    FALSE           reduce using rule 9 (declaration -> funcDeclaration .)
    RBCKT           reduce using rule 9 (declaration -> funcDeclaration .)
    CLOSP           reduce using rule 9 (declaration -> funcDeclaration .)


state 11

    (30) stmt -> expression .

    IF              reduce using rule 30 (stmt -> expression .)
    FOR             reduce using rule 30 (stmt -> expression .)
    WHILE           reduce using rule 30 (stmt -> expression .)
    STDIN           reduce using rule 30 (stmt -> expression .)
    PRINTLN         reduce using rule 30 (stmt -> expression .)
    INTVR           reduce using rule 30 (stmt -> expression .)
    STRNG           reduce using rule 30 (stmt -> expression .)
    IDVAR           reduce using rule 30 (stmt -> expression .)
    TRUE            reduce using rule 30 (stmt -> expression .)
    FALSE           reduce using rule 30 (stmt -> expression .)
    LET             reduce using rule 30 (stmt -> expression .)
    CONST           reduce using rule 30 (stmt -> expression .)
    STATIC          reduce using rule 30 (stmt -> expression .)
    FN              reduce using rule 30 (stmt -> expression .)
    $end            reduce using rule 30 (stmt -> expression .)
    RBCKT           reduce using rule 30 (stmt -> expression .)
    CLOSP           reduce using rule 30 (stmt -> expression .)


state 12

    (32) stmt -> selectionStmt .

    IF              reduce using rule 32 (stmt -> selectionStmt .)
    FOR             reduce using rule 32 (stmt -> selectionStmt .)
    WHILE           reduce using rule 32 (stmt -> selectionStmt .)
    STDIN           reduce using rule 32 (stmt -> selectionStmt .)
    PRINTLN         reduce using rule 32 (stmt -> selectionStmt .)
    INTVR           reduce using rule 32 (stmt -> selectionStmt .)
    STRNG           reduce using rule 32 (stmt -> selectionStmt .)
    IDVAR           reduce using rule 32 (stmt -> selectionStmt .)
    TRUE            reduce using rule 32 (stmt -> selectionStmt .)
    FALSE           reduce using rule 32 (stmt -> selectionStmt .)
    LET             reduce using rule 32 (stmt -> selectionStmt .)
    CONST           reduce using rule 32 (stmt -> selectionStmt .)
    STATIC          reduce using rule 32 (stmt -> selectionStmt .)
    FN              reduce using rule 32 (stmt -> selectionStmt .)
    $end            reduce using rule 32 (stmt -> selectionStmt .)
    RBCKT           reduce using rule 32 (stmt -> selectionStmt .)
    CLOSP           reduce using rule 32 (stmt -> selectionStmt .)


state 13

    (33) stmt -> iterationStmt .

    IF              reduce using rule 33 (stmt -> iterationStmt .)
    FOR             reduce using rule 33 (stmt -> iterationStmt .)
    WHILE           reduce using rule 33 (stmt -> iterationStmt .)
    STDIN           reduce using rule 33 (stmt -> iterationStmt .)
    PRINTLN         reduce using rule 33 (stmt -> iterationStmt .)
    INTVR           reduce using rule 33 (stmt -> iterationStmt .)
    STRNG           reduce using rule 33 (stmt -> iterationStmt .)
    IDVAR           reduce using rule 33 (stmt -> iterationStmt .)
    TRUE            reduce using rule 33 (stmt -> iterationStmt .)
    FALSE           reduce using rule 33 (stmt -> iterationStmt .)
    LET             reduce using rule 33 (stmt -> iterationStmt .)
    CONST           reduce using rule 33 (stmt -> iterationStmt .)
    STATIC          reduce using rule 33 (stmt -> iterationStmt .)
    FN              reduce using rule 33 (stmt -> iterationStmt .)
    $end            reduce using rule 33 (stmt -> iterationStmt .)
    RBCKT           reduce using rule 33 (stmt -> iterationStmt .)
    CLOSP           reduce using rule 33 (stmt -> iterationStmt .)


state 14

    (34) stmt -> inputStmt .

    IF              reduce using rule 34 (stmt -> inputStmt .)
    FOR             reduce using rule 34 (stmt -> inputStmt .)
    WHILE           reduce using rule 34 (stmt -> inputStmt .)
    STDIN           reduce using rule 34 (stmt -> inputStmt .)
    PRINTLN         reduce using rule 34 (stmt -> inputStmt .)
    INTVR           reduce using rule 34 (stmt -> inputStmt .)
    STRNG           reduce using rule 34 (stmt -> inputStmt .)
    IDVAR           reduce using rule 34 (stmt -> inputStmt .)
    TRUE            reduce using rule 34 (stmt -> inputStmt .)
    FALSE           reduce using rule 34 (stmt -> inputStmt .)
    LET             reduce using rule 34 (stmt -> inputStmt .)
    CONST           reduce using rule 34 (stmt -> inputStmt .)
    STATIC          reduce using rule 34 (stmt -> inputStmt .)
    FN              reduce using rule 34 (stmt -> inputStmt .)
    $end            reduce using rule 34 (stmt -> inputStmt .)
    RBCKT           reduce using rule 34 (stmt -> inputStmt .)
    CLOSP           reduce using rule 34 (stmt -> inputStmt .)


state 15

    (35) stmt -> outputStmt .

    IF              reduce using rule 35 (stmt -> outputStmt .)
    FOR             reduce using rule 35 (stmt -> outputStmt .)
    WHILE           reduce using rule 35 (stmt -> outputStmt .)
    STDIN           reduce using rule 35 (stmt -> outputStmt .)
    PRINTLN         reduce using rule 35 (stmt -> outputStmt .)
    INTVR           reduce using rule 35 (stmt -> outputStmt .)
    STRNG           reduce using rule 35 (stmt -> outputStmt .)
    IDVAR           reduce using rule 35 (stmt -> outputStmt .)
    TRUE            reduce using rule 35 (stmt -> outputStmt .)
    FALSE           reduce using rule 35 (stmt -> outputStmt .)
    LET             reduce using rule 35 (stmt -> outputStmt .)
    CONST           reduce using rule 35 (stmt -> outputStmt .)
    STATIC          reduce using rule 35 (stmt -> outputStmt .)
    FN              reduce using rule 35 (stmt -> outputStmt .)
    $end            reduce using rule 35 (stmt -> outputStmt .)
    RBCKT           reduce using rule 35 (stmt -> outputStmt .)
    CLOSP           reduce using rule 35 (stmt -> outputStmt .)


state 16

    (10) varDeclaration -> LET . IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> LET . IDVAR EQUAL identifier SEMCL

    IDVAR           shift and go to state 39


state 17

    (42) basicExp -> IDVAR .
    (45) identifier -> IDVAR .

  ! reduce/reduce conflict for EQUAL resolved using rule 42 (basicExp -> IDVAR .)
    LESST           reduce using rule 42 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 42 (basicExp -> IDVAR .)
    GREAT           reduce using rule 42 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 42 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 42 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 42 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 42 (basicExp -> IDVAR .)
    IF              reduce using rule 42 (basicExp -> IDVAR .)
    FOR             reduce using rule 42 (basicExp -> IDVAR .)
    WHILE           reduce using rule 42 (basicExp -> IDVAR .)
    STDIN           reduce using rule 42 (basicExp -> IDVAR .)
    PRINTLN         reduce using rule 42 (basicExp -> IDVAR .)
    INTVR           reduce using rule 42 (basicExp -> IDVAR .)
    STRNG           reduce using rule 42 (basicExp -> IDVAR .)
    IDVAR           reduce using rule 42 (basicExp -> IDVAR .)
    TRUE            reduce using rule 42 (basicExp -> IDVAR .)
    FALSE           reduce using rule 42 (basicExp -> IDVAR .)
    LET             reduce using rule 42 (basicExp -> IDVAR .)
    CONST           reduce using rule 42 (basicExp -> IDVAR .)
    STATIC          reduce using rule 42 (basicExp -> IDVAR .)
    FN              reduce using rule 42 (basicExp -> IDVAR .)
    $end            reduce using rule 42 (basicExp -> IDVAR .)
    RBCKT           reduce using rule 42 (basicExp -> IDVAR .)
    IN              reduce using rule 42 (basicExp -> IDVAR .)
    SEMCL           reduce using rule 42 (basicExp -> IDVAR .)
    CLOSP           reduce using rule 42 (basicExp -> IDVAR .)
    ADDOP           reduce using rule 45 (identifier -> IDVAR .)
    SUBOP           reduce using rule 45 (identifier -> IDVAR .)
    DEROP           reduce using rule 45 (identifier -> IDVAR .)
    QUOOP           reduce using rule 45 (identifier -> IDVAR .)
    REMOP           reduce using rule 45 (identifier -> IDVAR .)

  ! EQUAL           [ reduce using rule 45 (identifier -> IDVAR .) ]


state 18

    (43) assignmentExp -> identifier . sumOp basicExp
    (44) assignmentExp -> identifier . sumOp assignmentExp
    (56) sumOp -> . ADDOP
    (57) sumOp -> . SUBOP
    (58) sumOp -> . DEROP
    (59) sumOp -> . QUOOP
    (60) sumOp -> . EQUAL
    (61) sumOp -> . REMOP

    ADDOP           shift and go to state 41
    SUBOP           shift and go to state 42
    DEROP           shift and go to state 43
    QUOOP           shift and go to state 44
    EQUAL           shift and go to state 45
    REMOP           shift and go to state 46

    sumOp                          shift and go to state 40

state 19

    (12) constDeclaration -> CONST . IDVAR EQUAL expression SEMCL

    IDVAR           shift and go to state 47


state 20

    (13) staticDeclaration -> STATIC . IDVAR EQUAL expression SEMCL

    IDVAR           shift and go to state 48


state 21

    (14) funcDeclaration -> FN . function
    (15) function -> . IDVAR parameters block

    IDVAR           shift and go to state 50

    function                       shift and go to state 49

state 22

    (36) expression -> basicExp .
    (47) comparisonExp -> basicExp . relop basicExp
    (48) comparisonExp -> basicExp . relop comparisonExp
    (49) relop -> . LESST
    (50) relop -> . LSSEQ
    (51) relop -> . GREAT
    (52) relop -> . GRTEQ
    (53) relop -> . EQUAL
    (54) relop -> . UNEQL
    (55) relop -> . EQLTO

    IF              reduce using rule 36 (expression -> basicExp .)
    FOR             reduce using rule 36 (expression -> basicExp .)
    WHILE           reduce using rule 36 (expression -> basicExp .)
    STDIN           reduce using rule 36 (expression -> basicExp .)
    PRINTLN         reduce using rule 36 (expression -> basicExp .)
    INTVR           reduce using rule 36 (expression -> basicExp .)
    STRNG           reduce using rule 36 (expression -> basicExp .)
    IDVAR           reduce using rule 36 (expression -> basicExp .)
    TRUE            reduce using rule 36 (expression -> basicExp .)
    FALSE           reduce using rule 36 (expression -> basicExp .)
    LET             reduce using rule 36 (expression -> basicExp .)
    CONST           reduce using rule 36 (expression -> basicExp .)
    STATIC          reduce using rule 36 (expression -> basicExp .)
    FN              reduce using rule 36 (expression -> basicExp .)
    $end            reduce using rule 36 (expression -> basicExp .)
    RBCKT           reduce using rule 36 (expression -> basicExp .)
    IN              reduce using rule 36 (expression -> basicExp .)
    CLOSP           reduce using rule 36 (expression -> basicExp .)
    SEMCL           reduce using rule 36 (expression -> basicExp .)
    LESST           shift and go to state 52
    LSSEQ           shift and go to state 53
    GREAT           shift and go to state 54
    GRTEQ           shift and go to state 55
    EQUAL           shift and go to state 56
    UNEQL           shift and go to state 57
    EQLTO           shift and go to state 58

    relop                          shift and go to state 51

state 23

    (37) expression -> assignmentExp . SEMCL

    SEMCL           shift and go to state 59


state 24

    (38) expression -> comparisonExp .

    IF              reduce using rule 38 (expression -> comparisonExp .)
    FOR             reduce using rule 38 (expression -> comparisonExp .)
    WHILE           reduce using rule 38 (expression -> comparisonExp .)
    STDIN           reduce using rule 38 (expression -> comparisonExp .)
    PRINTLN         reduce using rule 38 (expression -> comparisonExp .)
    INTVR           reduce using rule 38 (expression -> comparisonExp .)
    STRNG           reduce using rule 38 (expression -> comparisonExp .)
    IDVAR           reduce using rule 38 (expression -> comparisonExp .)
    TRUE            reduce using rule 38 (expression -> comparisonExp .)
    FALSE           reduce using rule 38 (expression -> comparisonExp .)
    LET             reduce using rule 38 (expression -> comparisonExp .)
    CONST           reduce using rule 38 (expression -> comparisonExp .)
    STATIC          reduce using rule 38 (expression -> comparisonExp .)
    FN              reduce using rule 38 (expression -> comparisonExp .)
    $end            reduce using rule 38 (expression -> comparisonExp .)
    RBCKT           reduce using rule 38 (expression -> comparisonExp .)
    IN              reduce using rule 38 (expression -> comparisonExp .)
    CLOSP           reduce using rule 38 (expression -> comparisonExp .)
    SEMCL           reduce using rule 38 (expression -> comparisonExp .)


state 25

    (39) expression -> boolExp .

    IF              reduce using rule 39 (expression -> boolExp .)
    FOR             reduce using rule 39 (expression -> boolExp .)
    WHILE           reduce using rule 39 (expression -> boolExp .)
    STDIN           reduce using rule 39 (expression -> boolExp .)
    PRINTLN         reduce using rule 39 (expression -> boolExp .)
    INTVR           reduce using rule 39 (expression -> boolExp .)
    STRNG           reduce using rule 39 (expression -> boolExp .)
    IDVAR           reduce using rule 39 (expression -> boolExp .)
    TRUE            reduce using rule 39 (expression -> boolExp .)
    FALSE           reduce using rule 39 (expression -> boolExp .)
    LET             reduce using rule 39 (expression -> boolExp .)
    CONST           reduce using rule 39 (expression -> boolExp .)
    STATIC          reduce using rule 39 (expression -> boolExp .)
    FN              reduce using rule 39 (expression -> boolExp .)
    $end            reduce using rule 39 (expression -> boolExp .)
    RBCKT           reduce using rule 39 (expression -> boolExp .)
    IN              reduce using rule 39 (expression -> boolExp .)
    CLOSP           reduce using rule 39 (expression -> boolExp .)
    SEMCL           reduce using rule 39 (expression -> boolExp .)


state 26

    (62) selectionStmt -> IF . OPENP expression CLOSP block
    (63) selectionStmt -> IF . OPENP expression CLOSP block ELSE block

    OPENP           shift and go to state 60


state 27

    (64) iterationStmt -> FOR . expression IN expression
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 61
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 28

    (65) iterationStmt -> WHILE . parameters block
    (16) parameters -> . OPENP CLOSP
    (17) parameters -> . OPENP paramList CLOSP
    (18) parameters -> . OPENP expression CLOSP

    OPENP           shift and go to state 63

    parameters                     shift and go to state 62

state 29

    (28) inputStmt -> STDIN . OPENP stmt CLOSP SEMCL

    OPENP           shift and go to state 64


state 30

    (29) outputStmt -> PRINTLN . OPENP stmt CLOSP SEMCL

    OPENP           shift and go to state 65


state 31

    (40) basicExp -> INTVR .
    (46) identifier -> INTVR .

  ! reduce/reduce conflict for EQUAL resolved using rule 40 (basicExp -> INTVR .)
    LESST           reduce using rule 40 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 40 (basicExp -> INTVR .)
    GREAT           reduce using rule 40 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 40 (basicExp -> INTVR .)
    EQUAL           reduce using rule 40 (basicExp -> INTVR .)
    UNEQL           reduce using rule 40 (basicExp -> INTVR .)
    EQLTO           reduce using rule 40 (basicExp -> INTVR .)
    IF              reduce using rule 40 (basicExp -> INTVR .)
    FOR             reduce using rule 40 (basicExp -> INTVR .)
    WHILE           reduce using rule 40 (basicExp -> INTVR .)
    STDIN           reduce using rule 40 (basicExp -> INTVR .)
    PRINTLN         reduce using rule 40 (basicExp -> INTVR .)
    INTVR           reduce using rule 40 (basicExp -> INTVR .)
    STRNG           reduce using rule 40 (basicExp -> INTVR .)
    IDVAR           reduce using rule 40 (basicExp -> INTVR .)
    TRUE            reduce using rule 40 (basicExp -> INTVR .)
    FALSE           reduce using rule 40 (basicExp -> INTVR .)
    LET             reduce using rule 40 (basicExp -> INTVR .)
    CONST           reduce using rule 40 (basicExp -> INTVR .)
    STATIC          reduce using rule 40 (basicExp -> INTVR .)
    FN              reduce using rule 40 (basicExp -> INTVR .)
    $end            reduce using rule 40 (basicExp -> INTVR .)
    RBCKT           reduce using rule 40 (basicExp -> INTVR .)
    IN              reduce using rule 40 (basicExp -> INTVR .)
    SEMCL           reduce using rule 40 (basicExp -> INTVR .)
    CLOSP           reduce using rule 40 (basicExp -> INTVR .)
    ADDOP           reduce using rule 46 (identifier -> INTVR .)
    SUBOP           reduce using rule 46 (identifier -> INTVR .)
    DEROP           reduce using rule 46 (identifier -> INTVR .)
    QUOOP           reduce using rule 46 (identifier -> INTVR .)
    REMOP           reduce using rule 46 (identifier -> INTVR .)

  ! EQUAL           [ reduce using rule 46 (identifier -> INTVR .) ]


state 32

    (41) basicExp -> STRNG .

    LESST           reduce using rule 41 (basicExp -> STRNG .)
    LSSEQ           reduce using rule 41 (basicExp -> STRNG .)
    GREAT           reduce using rule 41 (basicExp -> STRNG .)
    GRTEQ           reduce using rule 41 (basicExp -> STRNG .)
    EQUAL           reduce using rule 41 (basicExp -> STRNG .)
    UNEQL           reduce using rule 41 (basicExp -> STRNG .)
    EQLTO           reduce using rule 41 (basicExp -> STRNG .)
    IF              reduce using rule 41 (basicExp -> STRNG .)
    FOR             reduce using rule 41 (basicExp -> STRNG .)
    WHILE           reduce using rule 41 (basicExp -> STRNG .)
    STDIN           reduce using rule 41 (basicExp -> STRNG .)
    PRINTLN         reduce using rule 41 (basicExp -> STRNG .)
    INTVR           reduce using rule 41 (basicExp -> STRNG .)
    STRNG           reduce using rule 41 (basicExp -> STRNG .)
    IDVAR           reduce using rule 41 (basicExp -> STRNG .)
    TRUE            reduce using rule 41 (basicExp -> STRNG .)
    FALSE           reduce using rule 41 (basicExp -> STRNG .)
    LET             reduce using rule 41 (basicExp -> STRNG .)
    CONST           reduce using rule 41 (basicExp -> STRNG .)
    STATIC          reduce using rule 41 (basicExp -> STRNG .)
    FN              reduce using rule 41 (basicExp -> STRNG .)
    $end            reduce using rule 41 (basicExp -> STRNG .)
    RBCKT           reduce using rule 41 (basicExp -> STRNG .)
    IN              reduce using rule 41 (basicExp -> STRNG .)
    SEMCL           reduce using rule 41 (basicExp -> STRNG .)
    CLOSP           reduce using rule 41 (basicExp -> STRNG .)


state 33

    (66) boolExp -> TRUE .

    IF              reduce using rule 66 (boolExp -> TRUE .)
    FOR             reduce using rule 66 (boolExp -> TRUE .)
    WHILE           reduce using rule 66 (boolExp -> TRUE .)
    STDIN           reduce using rule 66 (boolExp -> TRUE .)
    PRINTLN         reduce using rule 66 (boolExp -> TRUE .)
    INTVR           reduce using rule 66 (boolExp -> TRUE .)
    STRNG           reduce using rule 66 (boolExp -> TRUE .)
    IDVAR           reduce using rule 66 (boolExp -> TRUE .)
    TRUE            reduce using rule 66 (boolExp -> TRUE .)
    FALSE           reduce using rule 66 (boolExp -> TRUE .)
    LET             reduce using rule 66 (boolExp -> TRUE .)
    CONST           reduce using rule 66 (boolExp -> TRUE .)
    STATIC          reduce using rule 66 (boolExp -> TRUE .)
    FN              reduce using rule 66 (boolExp -> TRUE .)
    $end            reduce using rule 66 (boolExp -> TRUE .)
    RBCKT           reduce using rule 66 (boolExp -> TRUE .)
    IN              reduce using rule 66 (boolExp -> TRUE .)
    CLOSP           reduce using rule 66 (boolExp -> TRUE .)
    SEMCL           reduce using rule 66 (boolExp -> TRUE .)


state 34

    (67) boolExp -> FALSE .

    IF              reduce using rule 67 (boolExp -> FALSE .)
    FOR             reduce using rule 67 (boolExp -> FALSE .)
    WHILE           reduce using rule 67 (boolExp -> FALSE .)
    STDIN           reduce using rule 67 (boolExp -> FALSE .)
    PRINTLN         reduce using rule 67 (boolExp -> FALSE .)
    INTVR           reduce using rule 67 (boolExp -> FALSE .)
    STRNG           reduce using rule 67 (boolExp -> FALSE .)
    IDVAR           reduce using rule 67 (boolExp -> FALSE .)
    TRUE            reduce using rule 67 (boolExp -> FALSE .)
    FALSE           reduce using rule 67 (boolExp -> FALSE .)
    LET             reduce using rule 67 (boolExp -> FALSE .)
    CONST           reduce using rule 67 (boolExp -> FALSE .)
    STATIC          reduce using rule 67 (boolExp -> FALSE .)
    FN              reduce using rule 67 (boolExp -> FALSE .)
    $end            reduce using rule 67 (boolExp -> FALSE .)
    RBCKT           reduce using rule 67 (boolExp -> FALSE .)
    IN              reduce using rule 67 (boolExp -> FALSE .)
    CLOSP           reduce using rule 67 (boolExp -> FALSE .)
    SEMCL           reduce using rule 67 (boolExp -> FALSE .)


state 35

    (4) declarationList -> declaration .
    (5) declarationList -> declaration . declarationList
    (4) declarationList -> . declaration
    (5) declarationList -> . declaration declarationList
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function

    $end            reduce using rule 4 (declarationList -> declaration .)
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

    declaration                    shift and go to state 35
    declarationList                shift and go to state 36
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10

state 36

    (5) declarationList -> declaration declarationList .

    $end            reduce using rule 5 (declarationList -> declaration declarationList .)


state 37

    (27) statement-list -> stmt statement-list .

    $end            reduce using rule 27 (statement-list -> stmt statement-list .)
    RBCKT           reduce using rule 27 (statement-list -> stmt statement-list .)


state 38

    (31) stmt -> declaration .

    IF              reduce using rule 31 (stmt -> declaration .)
    FOR             reduce using rule 31 (stmt -> declaration .)
    WHILE           reduce using rule 31 (stmt -> declaration .)
    STDIN           reduce using rule 31 (stmt -> declaration .)
    PRINTLN         reduce using rule 31 (stmt -> declaration .)
    INTVR           reduce using rule 31 (stmt -> declaration .)
    STRNG           reduce using rule 31 (stmt -> declaration .)
    IDVAR           reduce using rule 31 (stmt -> declaration .)
    TRUE            reduce using rule 31 (stmt -> declaration .)
    FALSE           reduce using rule 31 (stmt -> declaration .)
    LET             reduce using rule 31 (stmt -> declaration .)
    CONST           reduce using rule 31 (stmt -> declaration .)
    STATIC          reduce using rule 31 (stmt -> declaration .)
    FN              reduce using rule 31 (stmt -> declaration .)
    $end            reduce using rule 31 (stmt -> declaration .)
    RBCKT           reduce using rule 31 (stmt -> declaration .)
    CLOSP           reduce using rule 31 (stmt -> declaration .)


state 39

    (10) varDeclaration -> LET IDVAR . EQUAL expression SEMCL
    (11) varDeclaration -> LET IDVAR . EQUAL identifier SEMCL

    EQUAL           shift and go to state 66


state 40

    (43) assignmentExp -> identifier sumOp . basicExp
    (44) assignmentExp -> identifier sumOp . assignmentExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17

    identifier                     shift and go to state 18
    basicExp                       shift and go to state 67
    assignmentExp                  shift and go to state 68

state 41

    (56) sumOp -> ADDOP .

    INTVR           reduce using rule 56 (sumOp -> ADDOP .)
    STRNG           reduce using rule 56 (sumOp -> ADDOP .)
    IDVAR           reduce using rule 56 (sumOp -> ADDOP .)


state 42

    (57) sumOp -> SUBOP .

    INTVR           reduce using rule 57 (sumOp -> SUBOP .)
    STRNG           reduce using rule 57 (sumOp -> SUBOP .)
    IDVAR           reduce using rule 57 (sumOp -> SUBOP .)


state 43

    (58) sumOp -> DEROP .

    INTVR           reduce using rule 58 (sumOp -> DEROP .)
    STRNG           reduce using rule 58 (sumOp -> DEROP .)
    IDVAR           reduce using rule 58 (sumOp -> DEROP .)


state 44

    (59) sumOp -> QUOOP .

    INTVR           reduce using rule 59 (sumOp -> QUOOP .)
    STRNG           reduce using rule 59 (sumOp -> QUOOP .)
    IDVAR           reduce using rule 59 (sumOp -> QUOOP .)


state 45

    (60) sumOp -> EQUAL .

    INTVR           reduce using rule 60 (sumOp -> EQUAL .)
    STRNG           reduce using rule 60 (sumOp -> EQUAL .)
    IDVAR           reduce using rule 60 (sumOp -> EQUAL .)


state 46

    (61) sumOp -> REMOP .

    INTVR           reduce using rule 61 (sumOp -> REMOP .)
    STRNG           reduce using rule 61 (sumOp -> REMOP .)
    IDVAR           reduce using rule 61 (sumOp -> REMOP .)


state 47

    (12) constDeclaration -> CONST IDVAR . EQUAL expression SEMCL

    EQUAL           shift and go to state 69


state 48

    (13) staticDeclaration -> STATIC IDVAR . EQUAL expression SEMCL

    EQUAL           shift and go to state 70


state 49

    (14) funcDeclaration -> FN function .

    LET             reduce using rule 14 (funcDeclaration -> FN function .)
    CONST           reduce using rule 14 (funcDeclaration -> FN function .)
    STATIC          reduce using rule 14 (funcDeclaration -> FN function .)
    FN              reduce using rule 14 (funcDeclaration -> FN function .)
    $end            reduce using rule 14 (funcDeclaration -> FN function .)
    IF              reduce using rule 14 (funcDeclaration -> FN function .)
    FOR             reduce using rule 14 (funcDeclaration -> FN function .)
    WHILE           reduce using rule 14 (funcDeclaration -> FN function .)
    STDIN           reduce using rule 14 (funcDeclaration -> FN function .)
    PRINTLN         reduce using rule 14 (funcDeclaration -> FN function .)
    INTVR           reduce using rule 14 (funcDeclaration -> FN function .)
    STRNG           reduce using rule 14 (funcDeclaration -> FN function .)
    IDVAR           reduce using rule 14 (funcDeclaration -> FN function .)
    TRUE            reduce using rule 14 (funcDeclaration -> FN function .)
    FALSE           reduce using rule 14 (funcDeclaration -> FN function .)
    RBCKT           reduce using rule 14 (funcDeclaration -> FN function .)
    CLOSP           reduce using rule 14 (funcDeclaration -> FN function .)


state 50

    (15) function -> IDVAR . parameters block
    (16) parameters -> . OPENP CLOSP
    (17) parameters -> . OPENP paramList CLOSP
    (18) parameters -> . OPENP expression CLOSP

    OPENP           shift and go to state 63

    parameters                     shift and go to state 71

state 51

    (47) comparisonExp -> basicExp relop . basicExp
    (48) comparisonExp -> basicExp relop . comparisonExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp

    INTVR           shift and go to state 74
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 75

    basicExp                       shift and go to state 72
    comparisonExp                  shift and go to state 73

state 52

    (49) relop -> LESST .

    INTVR           reduce using rule 49 (relop -> LESST .)
    STRNG           reduce using rule 49 (relop -> LESST .)
    IDVAR           reduce using rule 49 (relop -> LESST .)


state 53

    (50) relop -> LSSEQ .

    INTVR           reduce using rule 50 (relop -> LSSEQ .)
    STRNG           reduce using rule 50 (relop -> LSSEQ .)
    IDVAR           reduce using rule 50 (relop -> LSSEQ .)


state 54

    (51) relop -> GREAT .

    INTVR           reduce using rule 51 (relop -> GREAT .)
    STRNG           reduce using rule 51 (relop -> GREAT .)
    IDVAR           reduce using rule 51 (relop -> GREAT .)


state 55

    (52) relop -> GRTEQ .

    INTVR           reduce using rule 52 (relop -> GRTEQ .)
    STRNG           reduce using rule 52 (relop -> GRTEQ .)
    IDVAR           reduce using rule 52 (relop -> GRTEQ .)


state 56

    (53) relop -> EQUAL .

    INTVR           reduce using rule 53 (relop -> EQUAL .)
    STRNG           reduce using rule 53 (relop -> EQUAL .)
    IDVAR           reduce using rule 53 (relop -> EQUAL .)


state 57

    (54) relop -> UNEQL .

    INTVR           reduce using rule 54 (relop -> UNEQL .)
    STRNG           reduce using rule 54 (relop -> UNEQL .)
    IDVAR           reduce using rule 54 (relop -> UNEQL .)


state 58

    (55) relop -> EQLTO .

    INTVR           reduce using rule 55 (relop -> EQLTO .)
    STRNG           reduce using rule 55 (relop -> EQLTO .)
    IDVAR           reduce using rule 55 (relop -> EQLTO .)


state 59

    (37) expression -> assignmentExp SEMCL .

    IF              reduce using rule 37 (expression -> assignmentExp SEMCL .)
    FOR             reduce using rule 37 (expression -> assignmentExp SEMCL .)
    WHILE           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    STDIN           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    PRINTLN         reduce using rule 37 (expression -> assignmentExp SEMCL .)
    INTVR           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    STRNG           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    IDVAR           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    TRUE            reduce using rule 37 (expression -> assignmentExp SEMCL .)
    FALSE           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    LET             reduce using rule 37 (expression -> assignmentExp SEMCL .)
    CONST           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    STATIC          reduce using rule 37 (expression -> assignmentExp SEMCL .)
    FN              reduce using rule 37 (expression -> assignmentExp SEMCL .)
    $end            reduce using rule 37 (expression -> assignmentExp SEMCL .)
    RBCKT           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    IN              reduce using rule 37 (expression -> assignmentExp SEMCL .)
    CLOSP           reduce using rule 37 (expression -> assignmentExp SEMCL .)
    SEMCL           reduce using rule 37 (expression -> assignmentExp SEMCL .)


state 60

    (62) selectionStmt -> IF OPENP . expression CLOSP block
    (63) selectionStmt -> IF OPENP . expression CLOSP block ELSE block
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 76
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 61

    (64) iterationStmt -> FOR expression . IN expression

    IN              shift and go to state 77


state 62

    (65) iterationStmt -> WHILE parameters . block
    (24) block -> . LBCKT RBCKT
    (25) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 79

    block                          shift and go to state 78

state 63

    (16) parameters -> OPENP . CLOSP
    (17) parameters -> OPENP . paramList CLOSP
    (18) parameters -> OPENP . expression CLOSP
    (19) paramList -> . parameter
    (20) paramList -> . parameter COMMA paramList
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (21) parameter -> . IDVAR
    (22) parameter -> . INTVR
    (23) parameter -> . STRNG
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    CLOSP           shift and go to state 80
    IDVAR           shift and go to state 84
    INTVR           shift and go to state 85
    STRNG           shift and go to state 86
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    paramList                      shift and go to state 81
    expression                     shift and go to state 82
    parameter                      shift and go to state 83
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 64

    (28) inputStmt -> STDIN OPENP . stmt CLOSP SEMCL
    (30) stmt -> . expression
    (31) stmt -> . declaration
    (32) stmt -> . selectionStmt
    (33) stmt -> . iterationStmt
    (34) stmt -> . inputStmt
    (35) stmt -> . outputStmt
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (62) selectionStmt -> . IF OPENP expression CLOSP block
    (63) selectionStmt -> . IF OPENP expression CLOSP block ELSE block
    (64) iterationStmt -> . FOR expression IN expression
    (65) iterationStmt -> . WHILE parameters block
    (28) inputStmt -> . STDIN OPENP stmt CLOSP SEMCL
    (29) outputStmt -> . PRINTLN OPENP stmt CLOSP SEMCL
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    IF              shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    STDIN           shift and go to state 29
    PRINTLN         shift and go to state 30
    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

    stmt                           shift and go to state 87
    expression                     shift and go to state 11
    declaration                    shift and go to state 38
    selectionStmt                  shift and go to state 12
    iterationStmt                  shift and go to state 13
    inputStmt                      shift and go to state 14
    outputStmt                     shift and go to state 15
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10
    identifier                     shift and go to state 18

state 65

    (29) outputStmt -> PRINTLN OPENP . stmt CLOSP SEMCL
    (30) stmt -> . expression
    (31) stmt -> . declaration
    (32) stmt -> . selectionStmt
    (33) stmt -> . iterationStmt
    (34) stmt -> . inputStmt
    (35) stmt -> . outputStmt
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (62) selectionStmt -> . IF OPENP expression CLOSP block
    (63) selectionStmt -> . IF OPENP expression CLOSP block ELSE block
    (64) iterationStmt -> . FOR expression IN expression
    (65) iterationStmt -> . WHILE parameters block
    (28) inputStmt -> . STDIN OPENP stmt CLOSP SEMCL
    (29) outputStmt -> . PRINTLN OPENP stmt CLOSP SEMCL
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    IF              shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    STDIN           shift and go to state 29
    PRINTLN         shift and go to state 30
    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

    stmt                           shift and go to state 88
    expression                     shift and go to state 11
    declaration                    shift and go to state 38
    selectionStmt                  shift and go to state 12
    iterationStmt                  shift and go to state 13
    inputStmt                      shift and go to state 14
    outputStmt                     shift and go to state 15
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10
    identifier                     shift and go to state 18

state 66

    (10) varDeclaration -> LET IDVAR EQUAL . expression SEMCL
    (11) varDeclaration -> LET IDVAR EQUAL . identifier SEMCL
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE

    IDVAR           shift and go to state 89
    INTVR           shift and go to state 92
    STRNG           shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 90
    identifier                     shift and go to state 91
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25

state 67

    (43) assignmentExp -> identifier sumOp basicExp .

    SEMCL           reduce using rule 43 (assignmentExp -> identifier sumOp basicExp .)


state 68

    (44) assignmentExp -> identifier sumOp assignmentExp .

    SEMCL           reduce using rule 44 (assignmentExp -> identifier sumOp assignmentExp .)


state 69

    (12) constDeclaration -> CONST IDVAR EQUAL . expression SEMCL
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 93
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 70

    (13) staticDeclaration -> STATIC IDVAR EQUAL . expression SEMCL
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 94
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 71

    (15) function -> IDVAR parameters . block
    (24) block -> . LBCKT RBCKT
    (25) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 79

    block                          shift and go to state 95

state 72

    (47) comparisonExp -> basicExp relop basicExp .
    (47) comparisonExp -> basicExp . relop basicExp
    (48) comparisonExp -> basicExp . relop comparisonExp
    (49) relop -> . LESST
    (50) relop -> . LSSEQ
    (51) relop -> . GREAT
    (52) relop -> . GRTEQ
    (53) relop -> . EQUAL
    (54) relop -> . UNEQL
    (55) relop -> . EQLTO

    IF              reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    FOR             reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    WHILE           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    STDIN           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    PRINTLN         reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    INTVR           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    STRNG           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    IDVAR           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    TRUE            reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    FALSE           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    LET             reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    CONST           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    STATIC          reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    FN              reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    $end            reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    RBCKT           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    IN              reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    CLOSP           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    SEMCL           reduce using rule 47 (comparisonExp -> basicExp relop basicExp .)
    LESST           shift and go to state 52
    LSSEQ           shift and go to state 53
    GREAT           shift and go to state 54
    GRTEQ           shift and go to state 55
    EQUAL           shift and go to state 56
    UNEQL           shift and go to state 57
    EQLTO           shift and go to state 58

    relop                          shift and go to state 51

state 73

    (48) comparisonExp -> basicExp relop comparisonExp .

    IF              reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    FOR             reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    WHILE           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    STDIN           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    PRINTLN         reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    INTVR           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    STRNG           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    IDVAR           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    TRUE            reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    FALSE           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    LET             reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    CONST           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    STATIC          reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    FN              reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    $end            reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    RBCKT           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    IN              reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    CLOSP           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)
    SEMCL           reduce using rule 48 (comparisonExp -> basicExp relop comparisonExp .)


state 74

    (40) basicExp -> INTVR .

    LESST           reduce using rule 40 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 40 (basicExp -> INTVR .)
    GREAT           reduce using rule 40 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 40 (basicExp -> INTVR .)
    EQUAL           reduce using rule 40 (basicExp -> INTVR .)
    UNEQL           reduce using rule 40 (basicExp -> INTVR .)
    EQLTO           reduce using rule 40 (basicExp -> INTVR .)
    IF              reduce using rule 40 (basicExp -> INTVR .)
    FOR             reduce using rule 40 (basicExp -> INTVR .)
    WHILE           reduce using rule 40 (basicExp -> INTVR .)
    STDIN           reduce using rule 40 (basicExp -> INTVR .)
    PRINTLN         reduce using rule 40 (basicExp -> INTVR .)
    INTVR           reduce using rule 40 (basicExp -> INTVR .)
    STRNG           reduce using rule 40 (basicExp -> INTVR .)
    IDVAR           reduce using rule 40 (basicExp -> INTVR .)
    TRUE            reduce using rule 40 (basicExp -> INTVR .)
    FALSE           reduce using rule 40 (basicExp -> INTVR .)
    LET             reduce using rule 40 (basicExp -> INTVR .)
    CONST           reduce using rule 40 (basicExp -> INTVR .)
    STATIC          reduce using rule 40 (basicExp -> INTVR .)
    FN              reduce using rule 40 (basicExp -> INTVR .)
    $end            reduce using rule 40 (basicExp -> INTVR .)
    RBCKT           reduce using rule 40 (basicExp -> INTVR .)
    IN              reduce using rule 40 (basicExp -> INTVR .)
    CLOSP           reduce using rule 40 (basicExp -> INTVR .)
    SEMCL           reduce using rule 40 (basicExp -> INTVR .)


state 75

    (42) basicExp -> IDVAR .

    LESST           reduce using rule 42 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 42 (basicExp -> IDVAR .)
    GREAT           reduce using rule 42 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 42 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 42 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 42 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 42 (basicExp -> IDVAR .)
    IF              reduce using rule 42 (basicExp -> IDVAR .)
    FOR             reduce using rule 42 (basicExp -> IDVAR .)
    WHILE           reduce using rule 42 (basicExp -> IDVAR .)
    STDIN           reduce using rule 42 (basicExp -> IDVAR .)
    PRINTLN         reduce using rule 42 (basicExp -> IDVAR .)
    INTVR           reduce using rule 42 (basicExp -> IDVAR .)
    STRNG           reduce using rule 42 (basicExp -> IDVAR .)
    IDVAR           reduce using rule 42 (basicExp -> IDVAR .)
    TRUE            reduce using rule 42 (basicExp -> IDVAR .)
    FALSE           reduce using rule 42 (basicExp -> IDVAR .)
    LET             reduce using rule 42 (basicExp -> IDVAR .)
    CONST           reduce using rule 42 (basicExp -> IDVAR .)
    STATIC          reduce using rule 42 (basicExp -> IDVAR .)
    FN              reduce using rule 42 (basicExp -> IDVAR .)
    $end            reduce using rule 42 (basicExp -> IDVAR .)
    RBCKT           reduce using rule 42 (basicExp -> IDVAR .)
    IN              reduce using rule 42 (basicExp -> IDVAR .)
    CLOSP           reduce using rule 42 (basicExp -> IDVAR .)
    SEMCL           reduce using rule 42 (basicExp -> IDVAR .)


state 76

    (62) selectionStmt -> IF OPENP expression . CLOSP block
    (63) selectionStmt -> IF OPENP expression . CLOSP block ELSE block

    CLOSP           shift and go to state 96


state 77

    (64) iterationStmt -> FOR expression IN . expression
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34

    expression                     shift and go to state 97
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    identifier                     shift and go to state 18

state 78

    (65) iterationStmt -> WHILE parameters block .

    IF              reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    FOR             reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    WHILE           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    STDIN           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    PRINTLN         reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    INTVR           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    STRNG           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    IDVAR           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    TRUE            reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    FALSE           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    LET             reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    CONST           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    STATIC          reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    FN              reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    $end            reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    RBCKT           reduce using rule 65 (iterationStmt -> WHILE parameters block .)
    CLOSP           reduce using rule 65 (iterationStmt -> WHILE parameters block .)


state 79

    (24) block -> LBCKT . RBCKT
    (25) block -> LBCKT . statement-list RBCKT
    (26) statement-list -> . stmt
    (27) statement-list -> . stmt statement-list
    (30) stmt -> . expression
    (31) stmt -> . declaration
    (32) stmt -> . selectionStmt
    (33) stmt -> . iterationStmt
    (34) stmt -> . inputStmt
    (35) stmt -> . outputStmt
    (36) expression -> . basicExp
    (37) expression -> . assignmentExp SEMCL
    (38) expression -> . comparisonExp
    (39) expression -> . boolExp
    (6) declaration -> . varDeclaration
    (7) declaration -> . constDeclaration
    (8) declaration -> . staticDeclaration
    (9) declaration -> . funcDeclaration
    (62) selectionStmt -> . IF OPENP expression CLOSP block
    (63) selectionStmt -> . IF OPENP expression CLOSP block ELSE block
    (64) iterationStmt -> . FOR expression IN expression
    (65) iterationStmt -> . WHILE parameters block
    (28) inputStmt -> . STDIN OPENP stmt CLOSP SEMCL
    (29) outputStmt -> . PRINTLN OPENP stmt CLOSP SEMCL
    (40) basicExp -> . INTVR
    (41) basicExp -> . STRNG
    (42) basicExp -> . IDVAR
    (43) assignmentExp -> . identifier sumOp basicExp
    (44) assignmentExp -> . identifier sumOp assignmentExp
    (47) comparisonExp -> . basicExp relop basicExp
    (48) comparisonExp -> . basicExp relop comparisonExp
    (66) boolExp -> . TRUE
    (67) boolExp -> . FALSE
    (10) varDeclaration -> . LET IDVAR EQUAL expression SEMCL
    (11) varDeclaration -> . LET IDVAR EQUAL identifier SEMCL
    (12) constDeclaration -> . CONST IDVAR EQUAL expression SEMCL
    (13) staticDeclaration -> . STATIC IDVAR EQUAL expression SEMCL
    (14) funcDeclaration -> . FN function
    (45) identifier -> . IDVAR
    (46) identifier -> . INTVR

    RBCKT           shift and go to state 98
    IF              shift and go to state 26
    FOR             shift and go to state 27
    WHILE           shift and go to state 28
    STDIN           shift and go to state 29
    PRINTLN         shift and go to state 30
    INTVR           shift and go to state 31
    STRNG           shift and go to state 32
    IDVAR           shift and go to state 17
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LET             shift and go to state 16
    CONST           shift and go to state 19
    STATIC          shift and go to state 20
    FN              shift and go to state 21

    statement-list                 shift and go to state 99
    stmt                           shift and go to state 6
    expression                     shift and go to state 11
    declaration                    shift and go to state 38
    selectionStmt                  shift and go to state 12
    iterationStmt                  shift and go to state 13
    inputStmt                      shift and go to state 14
    outputStmt                     shift and go to state 15
    basicExp                       shift and go to state 22
    assignmentExp                  shift and go to state 23
    comparisonExp                  shift and go to state 24
    boolExp                        shift and go to state 25
    varDeclaration                 shift and go to state 7
    constDeclaration               shift and go to state 8
    staticDeclaration              shift and go to state 9
    funcDeclaration                shift and go to state 10
    identifier                     shift and go to state 18

state 80

    (16) parameters -> OPENP CLOSP .

    LBCKT           reduce using rule 16 (parameters -> OPENP CLOSP .)


state 81

    (17) parameters -> OPENP paramList . CLOSP

    CLOSP           shift and go to state 100


state 82

    (18) parameters -> OPENP expression . CLOSP

    CLOSP           shift and go to state 101


state 83

    (19) paramList -> parameter .
    (20) paramList -> parameter . COMMA paramList

    CLOSP           reduce using rule 19 (paramList -> parameter .)
    COMMA           shift and go to state 102


state 84

    (21) parameter -> IDVAR .
    (42) basicExp -> IDVAR .
    (45) identifier -> IDVAR .

  ! reduce/reduce conflict for CLOSP resolved using rule 21 (parameter -> IDVAR .)
  ! reduce/reduce conflict for EQUAL resolved using rule 42 (basicExp -> IDVAR .)
    COMMA           reduce using rule 21 (parameter -> IDVAR .)
    CLOSP           reduce using rule 21 (parameter -> IDVAR .)
    LESST           reduce using rule 42 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 42 (basicExp -> IDVAR .)
    GREAT           reduce using rule 42 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 42 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 42 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 42 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 42 (basicExp -> IDVAR .)
    ADDOP           reduce using rule 45 (identifier -> IDVAR .)
    SUBOP           reduce using rule 45 (identifier -> IDVAR .)
    DEROP           reduce using rule 45 (identifier -> IDVAR .)
    QUOOP           reduce using rule 45 (identifier -> IDVAR .)
    REMOP           reduce using rule 45 (identifier -> IDVAR .)

  ! CLOSP           [ reduce using rule 42 (basicExp -> IDVAR .) ]
  ! EQUAL           [ reduce using rule 45 (identifier -> IDVAR .) ]


state 85

    (22) parameter -> INTVR .
    (40) basicExp -> INTVR .
    (46) identifier -> INTVR .

  ! reduce/reduce conflict for CLOSP resolved using rule 22 (parameter -> INTVR .)
  ! reduce/reduce conflict for EQUAL resolved using rule 40 (basicExp -> INTVR .)
    COMMA           reduce using rule 22 (parameter -> INTVR .)
    CLOSP           reduce using rule 22 (parameter -> INTVR .)
    LESST           reduce using rule 40 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 40 (basicExp -> INTVR .)
    GREAT           reduce using rule 40 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 40 (basicExp -> INTVR .)
    EQUAL           reduce using rule 40 (basicExp -> INTVR .)
    UNEQL           reduce using rule 40 (basicExp -> INTVR .)
    EQLTO           reduce using rule 40 (basicExp -> INTVR .)
    ADDOP           reduce using rule 46 (identifier -> INTVR .)
    SUBOP           reduce using rule 46 (identifier -> INTVR .)
    DEROP           reduce using rule 46 (identifier -> INTVR .)
    QUOOP           reduce using rule 46 (identifier -> INTVR .)
    REMOP           reduce using rule 46 (identifier -> INTVR .)

  ! CLOSP           [ reduce using rule 40 (basicExp -> INTVR .) ]
  ! EQUAL           [ reduce using rule 46 (identifier -> INTVR .) ]


state 86

    (23) parameter -> STRNG .
    (41) basicExp -> STRNG .

  ! reduce/reduce conflict for CLOSP resolved using rule 23 (parameter -> STRNG .)
    COMMA           reduce using rule 23 (parameter -> STRNG .)
    CLOSP           reduce using rule 23 (parameter -> STRNG .)
    LESST           reduce using rule 41 (basicExp -> STRNG .)
    LSSEQ           reduce using rule 41 (basicExp -> STRNG .)
    GREAT           reduce using rule 41 (basicExp -> STRNG .)
    GRTEQ           reduce using rule 41 (basicExp -> STRNG .)
    EQUAL           reduce using rule 41 (basicExp -> STRNG .)
    UNEQL           reduce using rule 41 (basicExp -> STRNG .)
    EQLTO           reduce using rule 41 (basicExp -> STRNG .)

  ! CLOSP           [ reduce using rule 41 (basicExp -> STRNG .) ]


state 87

    (28) inputStmt -> STDIN OPENP stmt . CLOSP SEMCL

    CLOSP           shift and go to state 103


state 88

    (29) outputStmt -> PRINTLN OPENP stmt . CLOSP SEMCL

    CLOSP           shift and go to state 104


state 89

    (45) identifier -> IDVAR .
    (42) basicExp -> IDVAR .

  ! reduce/reduce conflict for EQUAL resolved using rule 42 (basicExp -> IDVAR .)
  ! reduce/reduce conflict for SEMCL resolved using rule 42 (basicExp -> IDVAR .)
    ADDOP           reduce using rule 45 (identifier -> IDVAR .)
    SUBOP           reduce using rule 45 (identifier -> IDVAR .)
    DEROP           reduce using rule 45 (identifier -> IDVAR .)
    QUOOP           reduce using rule 45 (identifier -> IDVAR .)
    REMOP           reduce using rule 45 (identifier -> IDVAR .)
    LESST           reduce using rule 42 (basicExp -> IDVAR .)
    LSSEQ           reduce using rule 42 (basicExp -> IDVAR .)
    GREAT           reduce using rule 42 (basicExp -> IDVAR .)
    GRTEQ           reduce using rule 42 (basicExp -> IDVAR .)
    EQUAL           reduce using rule 42 (basicExp -> IDVAR .)
    UNEQL           reduce using rule 42 (basicExp -> IDVAR .)
    EQLTO           reduce using rule 42 (basicExp -> IDVAR .)
    SEMCL           reduce using rule 42 (basicExp -> IDVAR .)

  ! SEMCL           [ reduce using rule 45 (identifier -> IDVAR .) ]
  ! EQUAL           [ reduce using rule 45 (identifier -> IDVAR .) ]


state 90

    (10) varDeclaration -> LET IDVAR EQUAL expression . SEMCL

    SEMCL           shift and go to state 105


state 91

    (11) varDeclaration -> LET IDVAR EQUAL identifier . SEMCL
    (43) assignmentExp -> identifier . sumOp basicExp
    (44) assignmentExp -> identifier . sumOp assignmentExp
    (56) sumOp -> . ADDOP
    (57) sumOp -> . SUBOP
    (58) sumOp -> . DEROP
    (59) sumOp -> . QUOOP
    (60) sumOp -> . EQUAL
    (61) sumOp -> . REMOP

    SEMCL           shift and go to state 106
    ADDOP           shift and go to state 41
    SUBOP           shift and go to state 42
    DEROP           shift and go to state 43
    QUOOP           shift and go to state 44
    EQUAL           shift and go to state 45
    REMOP           shift and go to state 46

    sumOp                          shift and go to state 40

state 92

    (46) identifier -> INTVR .
    (40) basicExp -> INTVR .

  ! reduce/reduce conflict for EQUAL resolved using rule 40 (basicExp -> INTVR .)
  ! reduce/reduce conflict for SEMCL resolved using rule 40 (basicExp -> INTVR .)
    ADDOP           reduce using rule 46 (identifier -> INTVR .)
    SUBOP           reduce using rule 46 (identifier -> INTVR .)
    DEROP           reduce using rule 46 (identifier -> INTVR .)
    QUOOP           reduce using rule 46 (identifier -> INTVR .)
    REMOP           reduce using rule 46 (identifier -> INTVR .)
    LESST           reduce using rule 40 (basicExp -> INTVR .)
    LSSEQ           reduce using rule 40 (basicExp -> INTVR .)
    GREAT           reduce using rule 40 (basicExp -> INTVR .)
    GRTEQ           reduce using rule 40 (basicExp -> INTVR .)
    EQUAL           reduce using rule 40 (basicExp -> INTVR .)
    UNEQL           reduce using rule 40 (basicExp -> INTVR .)
    EQLTO           reduce using rule 40 (basicExp -> INTVR .)
    SEMCL           reduce using rule 40 (basicExp -> INTVR .)

  ! SEMCL           [ reduce using rule 46 (identifier -> INTVR .) ]
  ! EQUAL           [ reduce using rule 46 (identifier -> INTVR .) ]


state 93

    (12) constDeclaration -> CONST IDVAR EQUAL expression . SEMCL

    SEMCL           shift and go to state 107


state 94

    (13) staticDeclaration -> STATIC IDVAR EQUAL expression . SEMCL

    SEMCL           shift and go to state 108


state 95

    (15) function -> IDVAR parameters block .

    LET             reduce using rule 15 (function -> IDVAR parameters block .)
    CONST           reduce using rule 15 (function -> IDVAR parameters block .)
    STATIC          reduce using rule 15 (function -> IDVAR parameters block .)
    FN              reduce using rule 15 (function -> IDVAR parameters block .)
    $end            reduce using rule 15 (function -> IDVAR parameters block .)
    IF              reduce using rule 15 (function -> IDVAR parameters block .)
    FOR             reduce using rule 15 (function -> IDVAR parameters block .)
    WHILE           reduce using rule 15 (function -> IDVAR parameters block .)
    STDIN           reduce using rule 15 (function -> IDVAR parameters block .)
    PRINTLN         reduce using rule 15 (function -> IDVAR parameters block .)
    INTVR           reduce using rule 15 (function -> IDVAR parameters block .)
    STRNG           reduce using rule 15 (function -> IDVAR parameters block .)
    IDVAR           reduce using rule 15 (function -> IDVAR parameters block .)
    TRUE            reduce using rule 15 (function -> IDVAR parameters block .)
    FALSE           reduce using rule 15 (function -> IDVAR parameters block .)
    RBCKT           reduce using rule 15 (function -> IDVAR parameters block .)
    CLOSP           reduce using rule 15 (function -> IDVAR parameters block .)


state 96

    (62) selectionStmt -> IF OPENP expression CLOSP . block
    (63) selectionStmt -> IF OPENP expression CLOSP . block ELSE block
    (24) block -> . LBCKT RBCKT
    (25) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 79

    block                          shift and go to state 109

state 97

    (64) iterationStmt -> FOR expression IN expression .

    IF              reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    FOR             reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    WHILE           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    STDIN           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    PRINTLN         reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    INTVR           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    STRNG           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    IDVAR           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    TRUE            reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    FALSE           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    LET             reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    CONST           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    STATIC          reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    FN              reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    $end            reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    RBCKT           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)
    CLOSP           reduce using rule 64 (iterationStmt -> FOR expression IN expression .)


state 98

    (24) block -> LBCKT RBCKT .

    IF              reduce using rule 24 (block -> LBCKT RBCKT .)
    FOR             reduce using rule 24 (block -> LBCKT RBCKT .)
    WHILE           reduce using rule 24 (block -> LBCKT RBCKT .)
    STDIN           reduce using rule 24 (block -> LBCKT RBCKT .)
    PRINTLN         reduce using rule 24 (block -> LBCKT RBCKT .)
    INTVR           reduce using rule 24 (block -> LBCKT RBCKT .)
    STRNG           reduce using rule 24 (block -> LBCKT RBCKT .)
    IDVAR           reduce using rule 24 (block -> LBCKT RBCKT .)
    TRUE            reduce using rule 24 (block -> LBCKT RBCKT .)
    FALSE           reduce using rule 24 (block -> LBCKT RBCKT .)
    LET             reduce using rule 24 (block -> LBCKT RBCKT .)
    CONST           reduce using rule 24 (block -> LBCKT RBCKT .)
    STATIC          reduce using rule 24 (block -> LBCKT RBCKT .)
    FN              reduce using rule 24 (block -> LBCKT RBCKT .)
    $end            reduce using rule 24 (block -> LBCKT RBCKT .)
    RBCKT           reduce using rule 24 (block -> LBCKT RBCKT .)
    CLOSP           reduce using rule 24 (block -> LBCKT RBCKT .)
    ELSE            reduce using rule 24 (block -> LBCKT RBCKT .)


state 99

    (25) block -> LBCKT statement-list . RBCKT

    RBCKT           shift and go to state 110


state 100

    (17) parameters -> OPENP paramList CLOSP .

    LBCKT           reduce using rule 17 (parameters -> OPENP paramList CLOSP .)


state 101

    (18) parameters -> OPENP expression CLOSP .

    LBCKT           reduce using rule 18 (parameters -> OPENP expression CLOSP .)


state 102

    (20) paramList -> parameter COMMA . paramList
    (19) paramList -> . parameter
    (20) paramList -> . parameter COMMA paramList
    (21) parameter -> . IDVAR
    (22) parameter -> . INTVR
    (23) parameter -> . STRNG

    IDVAR           shift and go to state 112
    INTVR           shift and go to state 113
    STRNG           shift and go to state 114

    parameter                      shift and go to state 83
    paramList                      shift and go to state 111

state 103

    (28) inputStmt -> STDIN OPENP stmt CLOSP . SEMCL

    SEMCL           shift and go to state 115


state 104

    (29) outputStmt -> PRINTLN OPENP stmt CLOSP . SEMCL

    SEMCL           shift and go to state 116


state 105

    (10) varDeclaration -> LET IDVAR EQUAL expression SEMCL .

    LET             reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    CONST           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STATIC          reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FN              reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    $end            reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    IF              reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FOR             reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    WHILE           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STDIN           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    PRINTLN         reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    INTVR           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    STRNG           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    IDVAR           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    TRUE            reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    FALSE           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    RBCKT           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)
    CLOSP           reduce using rule 10 (varDeclaration -> LET IDVAR EQUAL expression SEMCL .)


state 106

    (11) varDeclaration -> LET IDVAR EQUAL identifier SEMCL .

    LET             reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    CONST           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    STATIC          reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    FN              reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    $end            reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    IF              reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    FOR             reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    WHILE           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    STDIN           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    PRINTLN         reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    INTVR           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    STRNG           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    IDVAR           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    TRUE            reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    FALSE           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    RBCKT           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)
    CLOSP           reduce using rule 11 (varDeclaration -> LET IDVAR EQUAL identifier SEMCL .)


state 107

    (12) constDeclaration -> CONST IDVAR EQUAL expression SEMCL .

    LET             reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    CONST           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    STATIC          reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    FN              reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    $end            reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    IF              reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    FOR             reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    WHILE           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    STDIN           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    PRINTLN         reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    INTVR           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    STRNG           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    IDVAR           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    TRUE            reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    FALSE           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    RBCKT           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)
    CLOSP           reduce using rule 12 (constDeclaration -> CONST IDVAR EQUAL expression SEMCL .)


state 108

    (13) staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .

    LET             reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    CONST           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    STATIC          reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    FN              reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    $end            reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    IF              reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    FOR             reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    WHILE           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    STDIN           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    PRINTLN         reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    INTVR           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    STRNG           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    IDVAR           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    TRUE            reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    FALSE           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    RBCKT           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)
    CLOSP           reduce using rule 13 (staticDeclaration -> STATIC IDVAR EQUAL expression SEMCL .)


state 109

    (62) selectionStmt -> IF OPENP expression CLOSP block .
    (63) selectionStmt -> IF OPENP expression CLOSP block . ELSE block

    IF              reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    FOR             reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    WHILE           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    STDIN           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    PRINTLN         reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    INTVR           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    STRNG           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    IDVAR           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    TRUE            reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    FALSE           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    LET             reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    CONST           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    STATIC          reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    FN              reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    $end            reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    RBCKT           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    CLOSP           reduce using rule 62 (selectionStmt -> IF OPENP expression CLOSP block .)
    ELSE            shift and go to state 117


state 110

    (25) block -> LBCKT statement-list RBCKT .

    IF              reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    FOR             reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    WHILE           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    STDIN           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    PRINTLN         reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    INTVR           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    STRNG           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    IDVAR           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    TRUE            reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    FALSE           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    LET             reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    CONST           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    STATIC          reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    FN              reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    $end            reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    RBCKT           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    CLOSP           reduce using rule 25 (block -> LBCKT statement-list RBCKT .)
    ELSE            reduce using rule 25 (block -> LBCKT statement-list RBCKT .)


state 111

    (20) paramList -> parameter COMMA paramList .

    CLOSP           reduce using rule 20 (paramList -> parameter COMMA paramList .)


state 112

    (21) parameter -> IDVAR .

    COMMA           reduce using rule 21 (parameter -> IDVAR .)
    CLOSP           reduce using rule 21 (parameter -> IDVAR .)


state 113

    (22) parameter -> INTVR .

    COMMA           reduce using rule 22 (parameter -> INTVR .)
    CLOSP           reduce using rule 22 (parameter -> INTVR .)


state 114

    (23) parameter -> STRNG .

    COMMA           reduce using rule 23 (parameter -> STRNG .)
    CLOSP           reduce using rule 23 (parameter -> STRNG .)


state 115

    (28) inputStmt -> STDIN OPENP stmt CLOSP SEMCL .

    IF              reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    FOR             reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    WHILE           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    STDIN           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    PRINTLN         reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    INTVR           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    STRNG           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    IDVAR           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    TRUE            reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    FALSE           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    LET             reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    CONST           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    STATIC          reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    FN              reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    $end            reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    RBCKT           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)
    CLOSP           reduce using rule 28 (inputStmt -> STDIN OPENP stmt CLOSP SEMCL .)


state 116

    (29) outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .

    IF              reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    FOR             reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    WHILE           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    STDIN           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    PRINTLN         reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    INTVR           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    STRNG           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    IDVAR           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    TRUE            reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    FALSE           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    LET             reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    CONST           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    STATIC          reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    FN              reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    $end            reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    RBCKT           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)
    CLOSP           reduce using rule 29 (outputStmt -> PRINTLN OPENP stmt CLOSP SEMCL .)


state 117

    (63) selectionStmt -> IF OPENP expression CLOSP block ELSE . block
    (24) block -> . LBCKT RBCKT
    (25) block -> . LBCKT statement-list RBCKT

    LBCKT           shift and go to state 79

    block                          shift and go to state 118

state 118

    (63) selectionStmt -> IF OPENP expression CLOSP block ELSE block .

    IF              reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    FOR             reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    WHILE           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    STDIN           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    PRINTLN         reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    INTVR           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    STRNG           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    IDVAR           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    TRUE            reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    FALSE           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    LET             reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    CONST           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    STATIC          reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    FN              reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    $end            reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    RBCKT           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)
    CLOSP           reduce using rule 63 (selectionStmt -> IF OPENP expression CLOSP block ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LET in state 5 resolved as shift
WARNING: shift/reduce conflict for CONST in state 5 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 5 resolved as shift
WARNING: shift/reduce conflict for FN in state 5 resolved as shift
WARNING: reduce/reduce conflict in state 5 resolved using rule (declarationList -> declaration)
WARNING: rejected rule (stmt -> declaration) in state 5
WARNING: reduce/reduce conflict in state 17 resolved using rule (basicExp -> IDVAR)
WARNING: rejected rule (identifier -> IDVAR) in state 17
WARNING: reduce/reduce conflict in state 31 resolved using rule (basicExp -> INTVR)
WARNING: rejected rule (identifier -> INTVR) in state 31
WARNING: reduce/reduce conflict in state 84 resolved using rule (parameter -> IDVAR)
WARNING: rejected rule (basicExp -> IDVAR) in state 84
WARNING: reduce/reduce conflict in state 84 resolved using rule (basicExp -> IDVAR)
WARNING: rejected rule (identifier -> IDVAR) in state 84
WARNING: reduce/reduce conflict in state 85 resolved using rule (parameter -> INTVR)
WARNING: rejected rule (basicExp -> INTVR) in state 85
WARNING: reduce/reduce conflict in state 85 resolved using rule (basicExp -> INTVR)
WARNING: rejected rule (identifier -> INTVR) in state 85
WARNING: reduce/reduce conflict in state 86 resolved using rule (parameter -> STRNG)
WARNING: rejected rule (basicExp -> STRNG) in state 86
WARNING: reduce/reduce conflict in state 89 resolved using rule (basicExp -> IDVAR)
WARNING: rejected rule (identifier -> IDVAR) in state 89
WARNING: reduce/reduce conflict in state 92 resolved using rule (basicExp -> INTVR)
WARNING: rejected rule (identifier -> INTVR) in state 92
